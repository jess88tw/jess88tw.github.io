[{"content":" Open Index Signature 還記得在 Java 的進階用法 Reflection 嗎?\n其實在 TypeScript 開放索引簽名 就有一點點相似於 Java 中的反射概念,\n因為它們都有提供動態地添加物件屬性的方法,\n而不需要事先定義固定的結構.\n舉例來說,\n在 Typescript 中, 我們可以使用 interface 來定義一個物件的型別:\ninterface Person { name: string; age: number; } 但是如果我們想要定義一個物件的型別,\n但是不確定它的屬性有哪些,\n可以使用 Open Index Signature:\ninterface Person { [key: string]: string | number; } 這樣就可以定義一個物件的型別,\n但是不確定它的屬性有哪些.\n定義 索引簽名的定義長這兩個樣子:\n// 透過字串 { [index: string]: type; } // 透過數字 { [index: number]: type; } index 可以是字串或是數字,\ntype 可以是任何型別.\n只能 選擇一種索引簽名 來定義物件的型別,\n不能同時使用字串和數字.\n字串索引簽名 使用字串作為索引來訪問對象的屬性.\n通常用來動態地添加屬性.\ninterface Cat { [key: string]: string; } const cat: Cat = {}; cat[\u0026#34;name\u0026#34;] = \u0026#34;Kitty\u0026#34;; cat[\u0026#34;age\u0026#34;] = \u0026#34;1\u0026#34;; console.log(cat[\u0026#34;name\u0026#34;]); // Kitty 數字索引簽名 使用數字作為索引來訪問對象的屬性.\n通常用來處理陣列.\ninterface CatArray { [key: number]: string; } const catArray: CatArray = []; catArray[0] = \u0026#34;Kitty\u0026#34;; catArray[1] = \u0026#34;Judy\u0026#34;; console.log(cat[0]); // Kitty 透過字串索引簽名訪問屬性 可以先定義一個物件的型別:\ninterface Person { name: string; age: number; [key: string]: string | number; } 然後再透過字串索引簽名來訪問屬性:\nconst person: Person = { name: \u0026#34;John\u0026#34;, age: 18, }; console.log(person.name); // John console.log(person[\u0026#34;age\u0026#34;]); // 18 person.gender = \u0026#34;male\u0026#34;; // 可以動態地添加屬性 console.log(person.gender); // male readonly 可以使用 readonly 關鍵字來設定屬性為唯讀:\ninterface Person { readonly name: string; readonly age: number; [key: string]: string | number; } const person: Person = { name: \u0026#34;John\u0026#34;, age: 18, }; person.name = \u0026#34;Mary\u0026#34;; // 會報錯 物件比對運用字串索引簽名 這是一個將物件的屬性排序的範例,\n直接比對物件的屬性會發現,\n雖然屬性的值都相同,\n但因為順序不同所以比對結果會是 false,\n但是如果先將物件的屬性排序,\n並運用字串索引簽名的方式獲取該物件屬性,\n動態添加排序後的屬性給新的物件,\n即可以得到正確的結果.\n// 索引簽名範例 const c: { [key: string]: number } = { a: 1, b: 2 }; const d: { [key: string]: number } = { b: 2, a: 1 }; const sortC: { [key: string]: number } = {}; const sortD: { [key: string]: number } = {}; Object.keys(c) .sort() .forEach((key) =\u0026gt; { sortC[key] = c[key]; }); Object.keys(d) .sort() .forEach((key) =\u0026gt; { sortD[key] = d[key]; }); console.log(JSON.stringify(c) === JSON.stringify(d)); // false console.log(JSON.stringify(sortC) === JSON.stringify(sortD)); // true 這邊有個小技巧, 就是使用 JSON.stringify() 來比對兩個物件是否相等.\n參考資料 TypeScript: 索引簽名, 輕鬆打造類型安全代碼!\nhttps://zhuanlan.zhihu.com/p/659382121 ","permalink":"https://www.jesseedgerunner.com/blog/blog_24/","summary":"Open Index Signature 還記得在 Java 的進階用法 Reflection 嗎?\n其實在 TypeScript 開放索引簽名 就有一點點相似於 Java 中的反射概念,\n因為它們都有提供動態地添加物件屬性的方法,\n而不需要事先定義固定的結構.\n舉例來說,\n在 Typescript 中, 我們可以使用 interface 來定義一個物件的型別:\ninterface Person { name: string; age: number; } 但是如果我們想要定義一個物件的型別,\n但是不確定它的屬性有哪些,\n可以使用 Open Index Signature:\ninterface Person { [key: string]: string | number; } 這樣就可以定義一個物件的型別,\n但是不確定它的屬性有哪些.\n定義 索引簽名的定義長這兩個樣子:\n// 透過字串 { [index: string]: type; } // 透過數字 { [index: number]: type; } index 可以是字串或是數字,\ntype 可以是任何型別.\n只能 選擇一種索引簽名 來定義物件的型別,","title":"Typescript Open Index Signature 用法"},{"content":" AtomicInteger AtomicInteger 是 java.util.concurrent.atomic 包下的其中一個 class,\n它提供了一個原子操作的 Integer,\n也就是說它可以在多線程環境下進行安全的操作.\n可以避免多線程環境變數的競爭問題.\n以下是一些常用的方法.\nget() get() 方法可以取得目前的值:\nAtomicInteger atomicInteger = new AtomicInteger(0); // 這邊可以預設初始值 int value = atomicInteger.get(); // 0 set() set() 方法可以設定目前的值:\nAtomicInteger atomicInteger = new AtomicInteger(0); atomicInteger.set(1); int value = atomicInteger.get(); // 1 getAndSet() getAndSet() 方法可以取得目前的值,\n並且設定新的值:\nAtomicInteger atomicInteger = new AtomicInteger(0); int value = atomicInteger.getAndSet(1); // 因為先取後加, 所以為 0 value = atomicInteger.get(); // 再取一次為 1 incrementAndGet() incrementAndGet() 方法可以將目前的值加 1,\n並且回傳新的值:\nAtomicInteger atomicInteger = new AtomicInteger(0); int value = atomicInteger.incrementAndGet(); // 1 value = atomicInteger.get(); // 再取一次為 1 decrementAndGet() decrementAndGet() 方法可以將目前的值減 1,\n並且回傳新的值:\nAtomicInteger atomicInteger = new AtomicInteger(0); int value = atomicInteger.decrementAndGet(); // -1 value = atomicInteger.get(); // 再取一次為 -1 getAndIncrement() getAndIncrement() 方法可以先取得目前的值,\n並且將目前的值加 1:\nAtomicInteger atomicInteger = new AtomicInteger(0); int value = atomicInteger.getAndIncrement(); // 0 value = atomicInteger.get(); // 再取一次為 1 getAndDecrement() getAndDecrement() 方法可以先取得目前的值,\n並且將目前的值減 1:\nAtomicInteger atomicInteger = new AtomicInteger(0); int value = atomicInteger.getAndDecrement(); // 0 value = atomicInteger.get(); // 再取一次為 -1 addAndGet() addAndGet() 方法可以將目前的值加上指定的值,\n並且回傳新的值:\nAtomicInteger atomicInteger = new AtomicInteger(0); int value = atomicInteger.addAndGet(2); // 2 value = atomicInteger.get(); // 再取一次為 2 getAndAdd() getAndAdd() 方法可以先取得目前的值,\n並且將目前的值加上指定的值:\nAtomicInteger atomicInteger = new AtomicInteger(0); int value = atomicInteger.getAndAdd(2); // 0 value = atomicInteger.get(); // 再取一次為 2 compareAndSet() compareAndSet() 方法可以比較目前的值是否等於指定的值,\n如果相等就設定新的值:\nAtomicInteger atomicInteger = new AtomicInteger(0); boolean result = atomicInteger.compareAndSet(0, 1); // true int value = atomicInteger.get(); // 1 ","permalink":"https://www.jesseedgerunner.com/blog/blog_23/","summary":"AtomicInteger AtomicInteger 是 java.util.concurrent.atomic 包下的其中一個 class,\n它提供了一個原子操作的 Integer,\n也就是說它可以在多線程環境下進行安全的操作.\n可以避免多線程環境變數的競爭問題.\n以下是一些常用的方法.\nget() get() 方法可以取得目前的值:\nAtomicInteger atomicInteger = new AtomicInteger(0); // 這邊可以預設初始值 int value = atomicInteger.get(); // 0 set() set() 方法可以設定目前的值:\nAtomicInteger atomicInteger = new AtomicInteger(0); atomicInteger.set(1); int value = atomicInteger.get(); // 1 getAndSet() getAndSet() 方法可以取得目前的值,\n並且設定新的值:\nAtomicInteger atomicInteger = new AtomicInteger(0); int value = atomicInteger.getAndSet(1); // 因為先取後加, 所以為 0 value = atomicInteger.get(); // 再取一次為 1 incrementAndGet() incrementAndGet() 方法可以將目前的值加 1,","title":"Java AtomicInteger 用法"},{"content":" 本週更新 我還活著!\nTODO.\n整理多奇教育 Angular 16 課程.\n持續維護部落格.\n研究 Spring boot 與 mongoDB 如何串接.\n負重前行 終於通過新公司的試用期了! 全力衝刺的感覺有夠爽, 認真算起來我也只花了 43 天就完成前端的學習, 應該也算是有給公司一個交代了吧. 希望他們可以覺得請到我沒有浪費錢.\n在進入專案後, 有很多不了解的地方, 不管是不同的公司運作流程亦或是不同的技術, 我都很感謝公司的其他前輩願意花時間開導我, 這裡的主管甚至會親自來跟我講解機制, 帶人帶心啊! 由衷的感謝各位讓我知道原來世界上還是有好人的, 從今天起我就是公司的狗.\n檢討這一段時間的表現, 通常我自己的個性就是衝一段時間就會彈性疲乏, 感覺最近下班後很混, 都躺在床上滑手機, 應該還是要花錢去上課才會比較痛, 差不多要回去原廠上個課了(大約 24000).\n接下來該做什麼?\n持續整理各種遇到的問題與解法.\n是時候把後端框架重新打底了!\n賺錢買房!\n","permalink":"https://www.jesseedgerunner.com/blog/blog_22/","summary":"本週更新 我還活著!\nTODO.\n整理多奇教育 Angular 16 課程.\n持續維護部落格.\n研究 Spring boot 與 mongoDB 如何串接.\n負重前行 終於通過新公司的試用期了! 全力衝刺的感覺有夠爽, 認真算起來我也只花了 43 天就完成前端的學習, 應該也算是有給公司一個交代了吧. 希望他們可以覺得請到我沒有浪費錢.\n在進入專案後, 有很多不了解的地方, 不管是不同的公司運作流程亦或是不同的技術, 我都很感謝公司的其他前輩願意花時間開導我, 這裡的主管甚至會親自來跟我講解機制, 帶人帶心啊! 由衷的感謝各位讓我知道原來世界上還是有好人的, 從今天起我就是公司的狗.\n檢討這一段時間的表現, 通常我自己的個性就是衝一段時間就會彈性疲乏, 感覺最近下班後很混, 都躺在床上滑手機, 應該還是要花錢去上課才會比較痛, 差不多要回去原廠上個課了(大約 24000).\n接下來該做什麼?\n持續整理各種遇到的問題與解法.\n是時候把後端框架重新打底了!\n賺錢買房!","title":"20230713 Weekly Report"},{"content":" Destructuring 解構賦值是一種 JavaScript 運算符號,\n可以將陣列或物件中的資料解構出來,\n並且賦值給變數.\n解構陣列 使用 陣列解構 將陣列元素賦給個別變數:\nconst arr = [1, 2, 3]; const [a, b, c] = arr; console.log(a); // 1 console.log(b); // 2 console.log(c); // 3 巢狀陣列 也可以解構:\nconst arr = [1, 2, 3, [4, 5, 6]]; const [a, b, c, [d, e, f]] = arr; console.log(a); // 1 console.log(b); // 2 console.log(c); // 3 console.log(d); // 4 console.log(e); // 5 console.log(f); // 6 解構物件 使用 物件解構 將物件屬性賦給個別變數:\nconst obj = { name: \u0026#34;John\u0026#34;, age: 30, city: \u0026#34;New York\u0026#34;, }; const { name, age, city } = obj; console.log(name); // John console.log(age); // 30 console.log(city); // New York 巢狀物件 也可以解構:\nconst obj = { name: \u0026#34;John\u0026#34;, age: 30, city: \u0026#34;New York\u0026#34;, cars: { car1: \u0026#34;Ford\u0026#34;, car2: \u0026#34;BMW\u0026#34;, car3: \u0026#34;Fiat\u0026#34;, }, }; const { name, age, city, cars } = obj; console.log(name); // John console.log(age); // 30 console.log(city); // New York console.log(cars); // { car1: \u0026#39;Ford\u0026#39;, car2: \u0026#39;BMW\u0026#39;, car3: \u0026#39;Fiat\u0026#39; } 解構物件並賦予預設值 使用物件解構將物件屬性賦給個別變數,\n並且 賦予預設值 :\nconst obj = { name: \u0026#34;John\u0026#34;, age: 30, city: \u0026#34;New York\u0026#34;, }; const { name, age, city, job = \u0026#34;Engineer\u0026#34; } = obj; console.log(name); // John console.log(age); // 30 console.log(city); // New York console.log(job); // Engineer 解構物件並賦予別名 使用物件解構將物件屬性賦給個別變數,\n並且 賦予別名 :\nconst obj = { name: \u0026#34;John\u0026#34;, age: 30, city: \u0026#34;New York\u0026#34;, }; const { name: myName, age: myAge, city: myCity } = obj; console.log(myName); // John console.log(myAge); // 30 console.log(myCity); // New York ","permalink":"https://www.jesseedgerunner.com/blog/blog_21/","summary":"Destructuring 解構賦值是一種 JavaScript 運算符號,\n可以將陣列或物件中的資料解構出來,\n並且賦值給變數.\n解構陣列 使用 陣列解構 將陣列元素賦給個別變數:\nconst arr = [1, 2, 3]; const [a, b, c] = arr; console.log(a); // 1 console.log(b); // 2 console.log(c); // 3 巢狀陣列 也可以解構:\nconst arr = [1, 2, 3, [4, 5, 6]]; const [a, b, c, [d, e, f]] = arr; console.log(a); // 1 console.log(b); // 2 console.log(c); // 3 console.log(d); // 4 console.log(e); // 5 console.log(f); // 6 解構物件 使用 物件解構 將物件屬性賦給個別變數:","title":"JavaScript Destructuring 用法"},{"content":" push() 將一個或多個元素添加到陣列的 末尾, 並返回陣列的新長度:\nconst arr = [1, 2, 3]; arr.push(4); console.log(arr); // expected output: Array [1, 2, 3, 4] pop() 從陣列中刪除 最後一個元素, 並返回該元素的值:\nconst arr = [1, 2, 3]; arr.pop(); console.log(arr); // expected output: Array [1, 2] shift() 從陣列中刪除 第一個元素, 並返回該元素的值:\nconst arr = [1, 2, 3]; arr.shift(); console.log(arr); // expected output: Array [2, 3] unshift() 將一個或多個元素添加到陣列的 開頭, 並返回陣列的新長度:\nconst arr = [1, 2, 3]; arr.unshift(4); console.log(arr); // expected output: Array [4, 1, 2, 3] map() 會將陣列中的每個元素 映射 到另一個函式中, 並回傳一個新的陣列.\nmap() 可以接收三個參數:\ncurrentValue =\u0026gt; 當前處理的元素, 為必須參數.\nindex =\u0026gt; 當前處理的元素的索引, 非必須參數.\narray =\u0026gt; 呼叫 map 的陣列, 非必須參數.\nconst arr = [1, 2, 3]; const newArr = arr.map((item, index, array) =\u0026gt; { return item * 2; }); console.log(newArr); // expected output: Array [2, 4, 6] filter() 會將陣列中的每個元素 過濾 到另一個函式中, 並回傳一個新的陣列:\nconst arr = [1, 2, 3]; const newArr = arr.filter((item) =\u0026gt; item \u0026gt; 1); console.log(newArr); // expected output: Array [2, 3] slice() 會回傳一個新的陣列, 其中包含 指定範圍 的元素:\nslice() 可以接收兩個參數:\nstart =\u0026gt; 開始切割的索引.\nend =\u0026gt; 結束切割的索引.\nconst arr = [1, 2, 3]; const newArr = arr.slice(1, 2); console.log(newArr); // expected output: Array [2] splice() 會從陣列中 刪除 元素, 也可以 插入 新元素, 並返回被刪除的元素:\nsplice() 可以接收三個參數:\nstart =\u0026gt; 開始刪除的索引.\ndeleteCount =\u0026gt; 刪除的元素個數.\nitem1, item2, ... =\u0026gt; 插入的元素.\nconst arr = [1, 2, 3]; const newArr = arr.splice(1, 1, 4, 5); console.log(newArr); // expected output: Array [2] console.log(arr); // expected output: Array [1, 4, 5, 3] every() 會檢測陣列中的每一個元素是否 都 符合條件, 並回傳布林值:\nconst arr = [1, 2, 3]; const result = arr.every((item) =\u0026gt; item \u0026gt; 1); console.log(result); // expected output: false some() 會檢測陣列中的每一個元素只要有 一個 符合條件, 就會回傳布林值:\nconst arr = [1, 2, 3]; const result = arr.some((item) =\u0026gt; item \u0026gt; 1); console.log(result); // expected output: true ","permalink":"https://www.jesseedgerunner.com/blog/blog_20/","summary":"push() 將一個或多個元素添加到陣列的 末尾, 並返回陣列的新長度:\nconst arr = [1, 2, 3]; arr.push(4); console.log(arr); // expected output: Array [1, 2, 3, 4] pop() 從陣列中刪除 最後一個元素, 並返回該元素的值:\nconst arr = [1, 2, 3]; arr.pop(); console.log(arr); // expected output: Array [1, 2] shift() 從陣列中刪除 第一個元素, 並返回該元素的值:\nconst arr = [1, 2, 3]; arr.shift(); console.log(arr); // expected output: Array [2, 3] unshift() 將一個或多個元素添加到陣列的 開頭, 並返回陣列的新長度:\nconst arr = [1, 2, 3]; arr.unshift(4); console.log(arr); // expected output: Array [4, 1, 2, 3] map() 會將陣列中的每個元素 映射 到另一個函式中, 並回傳一個新的陣列.","title":"JavaScript Array 常用方法"},{"content":" Json to TypeScript Interface 在開發 Angular 時常常會遇到需要將 Json 轉換成 TypeScript Interface 的需求,\n這時候可以使用 https://quicktype.io/ 所提供的 vscode 小工具,\n可以快速的將 Json 轉換成 TypeScript Interface.\n使用方式 假設我們有一個物件:\n{ \u0026#34;name\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;cars\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Ford\u0026#34;, \u0026#34;models\u0026#34;: [\u0026#34;Fiesta\u0026#34;, \u0026#34;Focus\u0026#34;, \u0026#34;Mustang\u0026#34;] }, { \u0026#34;name\u0026#34;: \u0026#34;BMW\u0026#34;, \u0026#34;models\u0026#34;: [\u0026#34;320\u0026#34;, \u0026#34;X3\u0026#34;, \u0026#34;X5\u0026#34;] }, { \u0026#34;name\u0026#34;: \u0026#34;Fiat\u0026#34;, \u0026#34;models\u0026#34;: [\u0026#34;500\u0026#34;, \u0026#34;Panda\u0026#34;] } ] } 按下 Ctrl + C 複製之後,\n在 vscode 中按下 Ctrl + Shift + P 開啟命令列,\n輸入 Paste JSON as Type 並按下 Enter,\n接著輸入你要的 interface 的名稱,\n就會自動產出 TypeScript Interface 了.\n","permalink":"https://www.jesseedgerunner.com/blog/blog_19/","summary":"Json to TypeScript Interface 在開發 Angular 時常常會遇到需要將 Json 轉換成 TypeScript Interface 的需求,\n這時候可以使用 https://quicktype.io/ 所提供的 vscode 小工具,\n可以快速的將 Json 轉換成 TypeScript Interface.\n使用方式 假設我們有一個物件:\n{ \u0026#34;name\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;cars\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Ford\u0026#34;, \u0026#34;models\u0026#34;: [\u0026#34;Fiesta\u0026#34;, \u0026#34;Focus\u0026#34;, \u0026#34;Mustang\u0026#34;] }, { \u0026#34;name\u0026#34;: \u0026#34;BMW\u0026#34;, \u0026#34;models\u0026#34;: [\u0026#34;320\u0026#34;, \u0026#34;X3\u0026#34;, \u0026#34;X5\u0026#34;] }, { \u0026#34;name\u0026#34;: \u0026#34;Fiat\u0026#34;, \u0026#34;models\u0026#34;: [\u0026#34;500\u0026#34;, \u0026#34;Panda\u0026#34;] } ] } 按下 Ctrl + C 複製之後,\n在 vscode 中按下 Ctrl + Shift + P 開啟命令列,","title":"Json to TypeScript Interface 快速轉換"},{"content":" Jasmine 是甚麼 ? Jasmine 是一個 JavaScript 的測試框架,\n提供了一系列的 API 用於執行單元測試,\n在 Angular 也常常使用 Jasmine 來進行測試.\n安裝 Jasmine Jasmine 已經預先安裝在 Angular CLI 中,\n只需要使用 ng test 執行測試就可以了,\n如果要在其他地方使用的話,\n可以使用 npm 或 yarn 來安裝 Jasmine.\n創建測試套件 一開始我們需要創建一個 測試套件,\n並在其中定義測試用例.\n可以使用 describe 函數來創建測試套件.\ndescribe(\u0026#39;登入頁功能\u0026#39;, () =\u0026gt; { . . . }); 創建測試用例 在測試套件中,\n需要使用 it 函數來創建測試用例.\nit 函數需要兩個參數,\n描述 和 函數,\n其中包含實際的 測試邏輯.\ndescribe(\u0026#39;登入頁功能\u0026#39;, () =\u0026gt; { it(\u0026#39;應該檢核帳密輸入\u0026#39;, () =\u0026gt; { expect something... }); }); 撰寫斷言 在測試用例中需要撰寫 斷言,\n以判斷測試結果是否符合預期.\nJasmine 提供了許多內置的 匹配器 用於撰寫斷言.\ndescribe(\u0026#34;登入頁功能\u0026#34;, () =\u0026gt; { it(\u0026#34;應該檢查帳密輸入\u0026#34;, () =\u0026gt; { const something = \u0026#34;something\u0026#34;; expect(something).toEqual(\u0026#34;something\u0026#34;); }); }); 運行測試 接著運行測試套件,\n以檢查程式及邏輯是否正常運行,\n在 Angular CLI 中,\n使用 ng test 來執行單元測試.\nJasmine 撰寫規範 編寫 可讀性高 的測試用例描述.\n將測試用例 分組, 提高可維護性.\n使用 beforeEach 和 afterEach, 避免執行重複的操作.\n避免在測試用例之間共享狀態, 每個單元測試應該要獨立運行.\nSuit \u0026amp; Spec 單元測試應該要這樣寫:\ndescribe(\u0026#39;登入頁功能\u0026#39;, () =\u0026gt; { it(\u0026#39;應該檢核帳密輸入\u0026#39;, () =\u0026gt; { expect something... }); it(\u0026#39;若登入成功，應該跳轉到系統頁\u0026#39;, () =\u0026gt; { expect something... }); }); describe 巢狀 可以將 describe 分組:\ndescribe(\u0026#39;登入頁功能\u0026#39;, () =\u0026gt; { it(\u0026#39;應該檢核帳密輸入\u0026#39;, () =\u0026gt; { expect something... }); describe(\u0026#39;登入成功後\u0026#39;, () =\u0026gt; { it(\u0026#39;應該跳轉到系統頁\u0026#39;, () =\u0026gt; { expect something... }); }); }); focus \u0026amp; skip 要執行特定的 describe 與 it 可以使用 f(focus):\ndescribe(\u0026#39;登入頁功能\u0026#39;, () =\u0026gt; { // 不執行 it(\u0026#39;應該檢核帳密輸入\u0026#39;, () =\u0026gt; { // 不執行 expect something... }); }); fdescribe(\u0026#39;登入成功後\u0026#39;, () =\u0026gt; { // 執行 it(\u0026#39;應儲存使用者資料\u0026#39;, () =\u0026gt; { // 不執行 expect something... }); fit(\u0026#39;應該跳轉到系統頁\u0026#39;, () =\u0026gt; { // 執行 expect something... }); }); 要跳過特定的 describe 與 it 可以使用 x:\nxdescribe(\u0026#39;登入頁功能\u0026#39;, () =\u0026gt; { // 不執行 it(\u0026#39;應該檢核帳密輸入\u0026#39;, () =\u0026gt; { // 不執行 expect something... }); }); describe(\u0026#39;登入成功後\u0026#39;, () =\u0026gt; { // 執行 xit(\u0026#39;應儲存使用者資料\u0026#39;, () =\u0026gt; { // 不執行 expect something... }); it(\u0026#39;應該跳轉到系統頁\u0026#39;, () =\u0026gt; { // 執行 expect something... }); }); 如果 xdescribe 遇到 fit 的時候:\nxdescribe(\u0026#39;登入頁功能\u0026#39;, () =\u0026gt; { // 不執行 it(\u0026#39;應該檢核帳密輸入\u0026#39;, () =\u0026gt; { // 不執行 expect something... }); }); xdescribe(\u0026#39;登入成功後\u0026#39;, () =\u0026gt; { // 因為 fit 的關係, 所也會執行 fit(\u0026#39;應儲存使用者資料\u0026#39;, () =\u0026gt; { // 還是會執行! expect something... }); it(\u0026#39;應該跳轉到系統頁\u0026#39;, () =\u0026gt; { // 執行 expect something... }); }); Setup \u0026amp; Teardown 在每個測試用例之前或之後執行某些操作.\nbeforeEach describe 執行後, 每個 it 被執行前, 執行 beforeEach:\ndescribe(\u0026#34;示範\u0026#34;, () =\u0026gt; { beforeEach(() =\u0026gt; { // do something ... }); }); afterEach 每個 it 執行後, 執行 afterEach:\ndescribe(\u0026#34;示範\u0026#34;, () =\u0026gt; { afterEach(() =\u0026gt; { // do something ... }); }); beforeAll describe 執行後, it 被執行前, 調用 beforeEach(只執行一次):\ndescribe(\u0026#34;示範\u0026#34;, () =\u0026gt; { beforeAll(() =\u0026gt; { // do something ... }); }); afterAll 全部 it 執行後, 調用 afterAll:\ndescribe(\u0026#34;示範\u0026#34;, () =\u0026gt; { afterAll(() =\u0026gt; { // do something ... }); }); Expect expect 用於撰寫斷言.\nexpect expect 可以用來預期參數或函式執行後為某數值或某行為:\nexpect(1).toBe(1); expect(1).not.toBe(2); expectAsync expectAsync 用於預期異步函式執行後為某數值或某行為:\nexpectAsync(1).toBeResolvedTo(1); expectAsync(1).not.toBeResolvedTo(2); Matchers 讓 expect 進行比較和匹配, 檢查 實際結果 與 期望結果, 進行判斷.\nnot not 用於反轉匹配:\nexpect(1).not.toBe(2); nothing nothing 用於檢查函式沒有回傳值:\nexpect().nothing(); toBe toBe 用於檢查兩個變數是否相等:\nexpect(1).toBe(1); toEqual toEqual 用於檢查兩個變數是否相等, 為深度比較:\nexpect(1).toEqual(1); toBeCloseTo toBeCloseTo 用於檢查兩個變數是否相等, 但是會忽略浮點數的誤差:\nexpect(0.1 + 0.2).not.toBe(0.3); // 0.30000000000000004 expect(0.1 + 0.2).toBeCloseTo(0.3); // 0.3 toBeDefined toBeDefined 用於檢查變數是否已定義:\nexpect(1).toBeDefined(); toBeUndefined toBeUndefined 用於檢查變數是否未定義:\nexpect(undefined).toBeUndefined(); toBeNaN toBeNaN 用於檢查變數是否為 NaN:\nexpect(NaN).toBeNaN(); toBeNull toBeNull 用於檢查變數是否為 null:\nexpect(null).toBeNull(); toBeFalse toBeFalse 用於檢查變數是否為 false:\nexpect(false).toBeFalse(); toBeTrue toBeTrue 用於檢查變數是否為 true:\nexpect(true).toBeTrue(); toBeFalsy toBeFalsy 用於檢查變數是否為 falsy:\nexpect(false).toBeFalsy(); toBeTruthy toBeTruthy 用於檢查變數是否為 truthy:\nexpect(1).toBeTruthy(); toBeGreaterThan toBeGreaterThan 用於檢查變數是否大於某數值:\nexpect(2).toBeGreaterThan(1); toBeGreaterThanOrEqual toBeGreaterThanOrEqual 用於檢查變數是否大於等於某數值:\nexpect(2).toBeGreaterThanOrEqual(1); expect(2).toBeGreaterThanOrEqual(2); toBeLessThan toBeLessThan 用於檢查變數是否小於某數值:\nexpect(1).toBeLessThan(2); toBeLessThanOrEqual toBeLessThanOrEqual 用於檢查變數是否小於等於某數值:\nexpect(1).toBeLessThanOrEqual(2); expect(1).toBeLessThanOrEqual(1); toBeInstanceOf toBeInstanceOf 用於檢查變數是否為某類別的實例:\nclass Foo {} expect(new Foo()).toBeInstanceOf(Foo); toBeNegativeInfinity toBeNegativeInfinity 用於檢查變數是否為負無窮大:\nexpect(Number.NEGATIVE_INFINITY).toBeNegativeInfinity(); toBePositiveInfinity toBePositiveInfinity 用於檢查變數是否為正無窮大:\nexpect(Number.POSITIVE_INFINITY).toBePositiveInfinity(); toBeContain toBeContain 用於檢查陣列是否包含某元素:\nexpect([1, 2, 3]).toContain(1); expect([{ v: \u0026#34;a\u0026#34; }, { v: \u0026#34;b\u0026#34; }]).toContain({ v: \u0026#34;a\u0026#34; }); expect(\u0026#34;abc\u0026#34;).toContain(\u0026#34;a\u0026#34;); toHaveBeenCalled toHaveBeenCalled 用於檢查 spy 方法是否被調用過:\nconst obj = { getData: (key) =\u0026gt; \u0026#34;aaaa\u0026#34;, }; spyOn(obj, \u0026#34;getData\u0026#34;); expect(obj.getData).not.toHaveBeenCalled(); obj.getData(\u0026#34;b\u0026#34;); expect(obj.getData).toHaveBeenCalled(); toHaveBeenCalledTimes toHaveBeenCalledTimes 用於檢查 spy 方法被調用的次數:\nconst obj = { getData: (key) =\u0026gt; \u0026#34;aaaa\u0026#34;, }; spyOn(obj, \u0026#34;getData\u0026#34;); expect(obj.getData).not.toHaveBeenCalledTimes(1); obj.getData(\u0026#34;b\u0026#34;); expect(obj.getData).toHaveBeenCalledTimes(1); toHaveBeenCalledWith toHaveBeenCalledWith 用於檢查 spy 方法被調用時的參數:\nconst obj = { getData: (key) =\u0026gt; \u0026#34;aaaa\u0026#34;, }; spyOn(obj, \u0026#34;getData\u0026#34;); expect(obj.getData).not.toHaveBeenCalledWith(\u0026#34;b\u0026#34;); obj.getData(\u0026#34;b\u0026#34;); expect(obj.getData).toHaveBeenCalledWith(\u0026#34;b\u0026#34;); toHaveBeenCalledBefore toHaveBeenCalledBefore 用於檢查 spy 方法是否在另一個 spy 方法之前被調用:\nconst obj = { getData: (key) =\u0026gt; \u0026#34;aaaa\u0026#34;, }; const obj2 = { getData: (key) =\u0026gt; \u0026#34;bbbb\u0026#34;, }; spyOn(obj, \u0026#34;getData\u0026#34;); spyOn(obj2, \u0026#34;getData\u0026#34;); obj.getData(\u0026#34;b\u0026#34;); obj2.getData(\u0026#34;b\u0026#34;); expect(obj.getData).toHaveBeenCalledBefore(obj2.getData); toHaveBeenCalledAfter toHaveBeenCalledAfter 用於檢查 spy 方法是否在另一個 spy 方法之後被調用:\nconst obj = { getData: (key) =\u0026gt; \u0026#34;aaaa\u0026#34;, }; const obj2 = { getData: (key) =\u0026gt; \u0026#34;bbbb\u0026#34;, }; spyOn(obj, \u0026#34;getData\u0026#34;); spyOn(obj2, \u0026#34;getData\u0026#34;); obj.getData(\u0026#34;b\u0026#34;); obj2.getData(\u0026#34;b\u0026#34;); expect(obj2.getData).toHaveBeenCalledAfter(obj.getData); toHaveClass toHaveClass 用於檢查元素是否有某個 class:\nconst el = document.createElement(\u0026#34;div\u0026#34;); el.classList.add(\u0026#34;foo\u0026#34;); expect(el).toHaveClass(\u0026#34;foo\u0026#34;); toHaveCssStyle toHaveCssStyle 用於檢查元素是否有某個 css style:\nconst el = document.createElement(\u0026#34;div\u0026#34;); el.style.color = \u0026#34;red\u0026#34;; expect(el).toHaveCssStyle({ color: \u0026#34;red\u0026#34; }); toMatch toMatch 用於檢查變數是否符合某正規表達式:\nexpect(\u0026#34;abc\u0026#34;).toMatch(/abc/); toMatchObject toMatchObject 用於檢查變數是否符合某物件:\nexpect({ a: 1, b: 2 }).toMatchObject({ a: 1 }); toThrow toThrow 用於檢查函式是否拋出錯誤:\nexpect(() =\u0026gt; { throw new Error(\u0026#34;error\u0026#34;); }).toThrow(\u0026#34;error\u0026#34;); toThrowError toThrowError 用於檢查函式是否拋出 特定錯誤類別 或是 特定錯誤訊息:\nconst a = () =\u0026gt; { throw new TypeError(\u0026#34;foo bar baz\u0026#34;); }; expect(a).toThrowError(TypeError); expect(a).toThrowError(\u0026#34;foo bar baz\u0026#34;); toThrowMatching toThrowMatching 用於檢查函式是否拋出指定錯誤值:\nexpect(() =\u0026gt; { throw new TypeError(\u0026#34;foo bar baz\u0026#34;); }).toThrowMatching((error) =\u0026gt; error.message === \u0026#34;foo bar baz\u0026#34;); withContext withContext 用於檢查函式是否拋出錯誤時, 有指定的上下文:\nexpect(() =\u0026gt; { throw new TypeError(\u0026#34;foo bar baz\u0026#34;); }).withContext(\u0026#34;error\u0026#34;); jasmine.any jasmine.any 用於檢查變數是否為某類別的實例:\nclass Foo {} expect(new Foo()).toEqual(jasmine.any(Foo)); jasmine.anything jasmine.anything 用於檢查變數是否為 undefined 或 null 以外的任何值:\nexpect(1).toEqual(jasmine.anything()); expect(null).not.toEqual(jasmine.anything()); expect(undefined).not.toEqual(jasmine.anything()); jasmine.truthy jasmine.truthy 用於檢查變數是否為 truthy:\nexpect(1).toEqual(jasmine.truthy()); jasmine.falsy jasmine.falsy 用於檢查變數是否為 falsy:\nexpect(0).toEqual(jasmine.falsy()); jasmine.empty jasmine.empty 用於檢查變數是否為空:\nexpect([]).toEqual(jasmine.empty()); jasmine.notEmpty jasmine.notEmpty 用於檢查變數是否不為空:\nexpect([1]).toEqual(jasmine.notEmpty()); jasmine.arrayContaining jasmine.arrayContaining 用於檢查陣列是否包含某元素:\nexpect([1, 2, 3]).toEqual(jasmine.arrayContaining([1])); jasmine.arrayWithExactContents jasmine.arrayWithExactContents 用於檢查陣列是否包含某元素, 且元素順序也要相同:\nexpect([1, 2, 3]).toEqual(jasmine.arrayWithExactContents([1, 2, 3])); jasmine.mapContaining jasmine.mapContaining 用於檢查物件是否包含在 Map 裡的 Key \u0026amp; value:\nexpect( new Map([ [\u0026#34;a\u0026#34;, 1], [\u0026#34;b\u0026#34;, 2], ]) ).toEqual(jasmine.mapContaining(new Map([[\u0026#34;a\u0026#34;, 1]]))); jasmine.objectContaining jasmine.objectContaining 用於檢查物件是否包含在 Object 裡的 Key \u0026amp; value:\nexpect({ a: 1, b: 2 }).toEqual(jasmine.objectContaining({ a: 1 })); jasmine.setContaining jasmine.setContaining 用於檢查 Set 是否包含某元素:\nexpect(new Set([1, 2, 3])).toEqual(jasmine.setContaining(1)); jasmine.stringMatching jasmine.stringMatching 用於檢查變數是否符合某正規表達式:\nexpect(\u0026#34;abc\u0026#34;).toEqual(jasmine.stringMatching(/abc/)); Spies spy 是一個函式, 可以監聽其他函式的呼叫情況.\nspyOn spyOn 用在原本就 有物件 並且該物件 也有方法, 這樣可以直接 spy 該物件的方法:\nconst car = { run:() =\u0026gt; { do something ... }; }; spyOn( car , \u0026#39;car\u0026#39;); spyOnProperty jasmine.createSpy 用在原本就 有物件, 但 不管有無方法, 都可以幫忙建立一個 spy 的方法:\nconst car = { // 有方法 run:() =\u0026gt; { do something ... }; }; car.run = jasmine.createSpy(); const car = {}; // 或者沒有方法也可以使用 car.run = jasmine.createSpy(); jasmine.createSpyObj jasmine.createSpyObj 用在原本就 沒有物件, 幫建立一個物件和多個 spy 的方法:\nconst car = jasmine.createSpyObj(\u0026#34;car\u0026#34;, [\u0026#34;run\u0026#34;, \u0026#34;fly\u0026#34;]); car.run.and.callFake(() =\u0026gt; \u0026#34;Here we go!!!\u0026#34;); car.fly.and.callFake(() =\u0026gt; \u0026#34;Boom!!!\u0026#34;); spyOnProperty spyOnProperty spy 物件的 getter 或 setter 方法:\nconst car = { _speed: 0, get speed() { return this._speed; }, set speed(value) { this._speed = value; }, }; spyOnProperty(car, \u0026#34;speed\u0026#34;, \u0026#34;get\u0026#34;).and.callFake(() =\u0026gt; 100); spyOnProperty(car, \u0026#34;speed\u0026#34;, \u0026#34;set\u0026#34;).and.cllFake((200) =\u0026gt; console.log(\u0026#39;do something ...\u0026#39;)); spyOnAllFunctions spyOnAllFunctions spy 物件的所有方法:\nconst car = { run:() =\u0026gt; { do something ... }; fly:() =\u0026gt; { do something ... }; }; spyOnAllFunctions(car); expect(car.run).toHaveBeenCalled(); expect(car.fly).not.toHaveBeenCalled(); Spy.withArgs withArgs 用於設置 spy 方法的參數.\nwithArgs withArgs 用在 spy 的方法有多個參數時, 可以指定要 spy 的參數做不同的事情:\nconst mockData = \u0026#34;bbbb\u0026#34;; const mockData2 = \u0026#34;cccc\u0026#34;; const obj = { getData: (key) =\u0026gt; \u0026#34;aaaa\u0026#34;, }; spyOn(obj, \u0026#34;getData\u0026#34;) .withArgs(\u0026#34;b\u0026#34;) .and.returnValue(mockData) .withArgs(\u0026#34;c\u0026#34;) .and.returnValue(mockData2); expect(obj.getData(\u0026#34;b\u0026#34;)).toBe(mockData); expect(obj.getData(\u0026#34;c\u0026#34;)).toBe(mockData2); Spy.and and 用在設置 spy 對象的行為.\nand.callThrough and.callThrough 會執行原本的方法:\nconst obj = { getData: (key) =\u0026gt; \u0026#34;aaaa\u0026#34;, }; spyOn(obj, \u0026#34;getData\u0026#34;).and.callThrough(); expect(obj.getData(\u0026#34;b\u0026#34;)).toBe(\u0026#34;aaaa\u0026#34;); and.callFake and.callFake 會執行自定義的方法:\nconst obj = { getData: (key) =\u0026gt; \u0026#34;aaaa\u0026#34;, }; spyOn(obj, \u0026#34;getData\u0026#34;).and.callFake(() =\u0026gt; \u0026#34;bbbb\u0026#34;); expect(obj.getData(\u0026#34;b\u0026#34;)).toBe(\u0026#34;bbbb\u0026#34;); and.returnValue and.returnValue 會回傳自定義的值:\nconst obj = { getData: (key) =\u0026gt; \u0026#34;aaaa\u0026#34;, }; spyOn(obj, \u0026#34;getData\u0026#34;).and.returnValue(\u0026#34;bbbb\u0026#34;); expect(obj.getData(\u0026#34;b\u0026#34;)).toBe(\u0026#34;bbbb\u0026#34;); and.returnValues and.returnValues 會回傳一系列自定義的值:\nconst obj = { getData: (key) =\u0026gt; \u0026#34;aaaa\u0026#34;, }; spyOn(obj, \u0026#34;getData\u0026#34;).and.returnValues(\u0026#34;bbbb\u0026#34;, \u0026#34;cccc\u0026#34;); // 按照提供的順序逐個返回 expect(obj.getData(\u0026#34;b\u0026#34;)).toBe(\u0026#34;bbbb\u0026#34;); expect(obj.getData(\u0026#34;c\u0026#34;)).toBe(\u0026#34;cccc\u0026#34;); and.stub and.stub 用於將 Spy 對象配置為使用原始的樣子, 而不是模擬或是替代行為.\n當調用 and.stub, 會清除任何先前的 Spy 設定並恢復對原始對象或方法的調用:\nconst obj = { getData: (key) =\u0026gt; \u0026#34;aaaa\u0026#34;, }; spyOn(obj, \u0026#34;getData\u0026#34;).and.returnValue(\u0026#34;bbbb\u0026#34;); expect(obj.getData(\u0026#34;b\u0026#34;)).toBe(\u0026#34;bbbb\u0026#34;); spyOn(obj, \u0026#34;getData\u0026#34;).and.stub(); // 恢復成原本的方法 expect(obj.getData(\u0026#34;b\u0026#34;)).toBe(\u0026#34;aaaa\u0026#34;); and.throwError and.throwError 會拋出錯誤:\nconst obj = { getData: (key) =\u0026gt; \u0026#34;aaaa\u0026#34;, }; spyOn(obj, \u0026#34;getData\u0026#34;).and.throwError(\u0026#34;error\u0026#34;); expect(() =\u0026gt; obj.getData(\u0026#34;b\u0026#34;)).toThrowError(\u0026#34;error\u0026#34;); Spy.calls calls 用於檢查 spy 方法的調用情況.\ncalls.any calls.any spy 方法是否被調用過, 會回傳 true 或 false:\nconst obj = { getData: (key) =\u0026gt; \u0026#34;aaaa\u0026#34;, }; spyOn(obj, \u0026#34;getData\u0026#34;); expect(obj.getData.calls.any()).toBe(false); obj.getData(\u0026#34;b\u0026#34;); expect(obj.getData.calls.any()).toBe(true); calls.all calls.all 回傳全部 spy 方法被調用時的紀錄:\nconst obj = { getData: (key) =\u0026gt; \u0026#34;aaaa\u0026#34;, }; spyOn(obj, \u0026#34;getData\u0026#34;); obj.getData(\u0026#34;b\u0026#34;); obj.getData(\u0026#34;c\u0026#34;); expect(obj.getData.calls.all()).toEqual([ { object: obj, args: [\u0026#34;b\u0026#34;], returnValue: \u0026#34;aaaa\u0026#34; }, { object: obj, args: [\u0026#34;c\u0026#34;], returnValue: \u0026#34;aaaa\u0026#34; }, ]); calls.allArgs calls.allArgs 回傳 spy 方法被調用時的所有參數:\nconst obj = { getData: (key) =\u0026gt; \u0026#34;aaaa\u0026#34;, }; spyOn(obj, \u0026#34;getData\u0026#34;); obj.getData(\u0026#34;b\u0026#34;); obj.getData(\u0026#34;c\u0026#34;); expect(obj.getData.calls.allArgs()).toEqual([[\u0026#34;b\u0026#34;], [\u0026#34;c\u0026#34;]]); calls.argsFor calls.argsFor 回傳 spy 方法第幾次被調用時的參數:\nconst obj = { getData: (key) =\u0026gt; \u0026#34;aaaa\u0026#34;, }; spyOn(obj, \u0026#34;getData\u0026#34;); obj.getData(\u0026#34;b\u0026#34;); expect(obj.getData.calls.argsFor(0)).toEqual([\u0026#34;b\u0026#34;]); calls.count calls.count 回傳 spy 方法被調用的次數:\nconst obj = { getData: (key) =\u0026gt; \u0026#34;aaaa\u0026#34;, }; spyOn(obj, \u0026#34;getData\u0026#34;); expect(obj.getData.calls.count()).toBe(0); obj.getData(\u0026#34;b\u0026#34;); expect(obj.getData.calls.count()).toBe(1); calls.first calls.first 回傳 spy 方法第一次被調用時的紀錄:\nconst obj = { getData: (key) =\u0026gt; \u0026#34;aaaa\u0026#34;, }; spyOn(obj, \u0026#34;getData\u0026#34;); obj.getData(\u0026#34;b\u0026#34;); obj.getData(\u0026#34;c\u0026#34;); expect(obj.getData.calls.first()).toEqual({ object: obj, args: [\u0026#34;b\u0026#34;], returnValue: \u0026#34;aaaa\u0026#34;, }); calls.mostRecent calls.mostRecent 回傳 spy 方法最後一次被調用時的紀錄:\nconst obj = { getData: (key) =\u0026gt; \u0026#34;aaaa\u0026#34;, }; spyOn(obj, \u0026#34;getData\u0026#34;); obj.getData(\u0026#34;b\u0026#34;); obj.getData(\u0026#34;c\u0026#34;); expect(obj.getData.calls.mostRecent()).toEqual({ object: obj, args: [\u0026#34;c\u0026#34;], returnValue: \u0026#34;aaaa\u0026#34;, }); calls.reset calls.reset 用於重置 spy 方法的調用情況:\nconst obj = { getData: (key) =\u0026gt; \u0026#34;aaaa\u0026#34;, }; spyOn(obj, \u0026#34;getData\u0026#34;); obj.getData(\u0026#34;b\u0026#34;); obj.getData(\u0026#34;c\u0026#34;); expect(obj.getData.calls.count()).toBe(2); obj.getData.calls.reset(); expect(obj.getData.calls.count()).toBe(0); Clock jasmine.clock 用於模擬時間.\ninstall jasmine.clock().install 安裝一個 clock:\nbeforeEach(() =\u0026gt; { jasmine.clock().install(); }); uninstall jasmine.clock().uninstall 解除一個 clock :\nafterEach(() =\u0026gt; { jasmine.clock().uninstall(); }); tick jasmine.clock().tick 快轉一段時間:\nbeforeEach(() =\u0026gt; { jasmine.clock().tick(50); }); mockDate jasmine.clock().mockDate mock 現在時間為某某時間:\nbeforeEach(() =\u0026gt; { jasmine.clock().mockDate(new Date(2013, 9, 23)); }); Done done 用於異步測試.\ndone done 用於異步測試, 等異步有反應後, 通知執行驗證:\nit(\u0026#34;示範測試異步程式碼\u0026#34;, (done) =\u0026gt; { let a = 0; setTimeout(() =\u0026gt; { a = 100; expect(a).toBe(100); done(); // 等待callback後，通知驗證 (非快轉，真的等3秒) }, 3000); expect(a).toBe(0); }); 使用 done() 是會等 callback 時間的,\n所以要注意每個 spec 預設等待驗證時間為 5s,\n超過的話 spec 還是報錯.\n因此若要調整 spec 的驗證時間,\n則可以使用 jasmine.DEFAULT_TIMEOUT_INTERVAL 去修改 spec 等待驗證的時間.\n","permalink":"https://www.jesseedgerunner.com/blog/blog_18/","summary":"Jasmine 是甚麼 ? Jasmine 是一個 JavaScript 的測試框架,\n提供了一系列的 API 用於執行單元測試,\n在 Angular 也常常使用 Jasmine 來進行測試.\n安裝 Jasmine Jasmine 已經預先安裝在 Angular CLI 中,\n只需要使用 ng test 執行測試就可以了,\n如果要在其他地方使用的話,\n可以使用 npm 或 yarn 來安裝 Jasmine.\n創建測試套件 一開始我們需要創建一個 測試套件,\n並在其中定義測試用例.\n可以使用 describe 函數來創建測試套件.\ndescribe(\u0026#39;登入頁功能\u0026#39;, () =\u0026gt; { . . . }); 創建測試用例 在測試套件中,\n需要使用 it 函數來創建測試用例.\nit 函數需要兩個參數,\n描述 和 函數,\n其中包含實際的 測試邏輯.\ndescribe(\u0026#39;登入頁功能\u0026#39;, () =\u0026gt; { it(\u0026#39;應該檢核帳密輸入\u0026#39;, () =\u0026gt; { expect something.","title":"Jasmine 常用方法"},{"content":" javascript 先在 javascript 試試看吧,\n比較舊的方法是使用 keyCode 或者是 which 進行判斷,\n再來是瀏覽器建議使用的 key 方法.\nkeyCode 可以在 javascript 這樣寫:\n\u0026lt;input type=\u0026#34;text\u0026#34; onkeydown=\u0026#34;handleKeyDown(event)\u0026#34; /\u0026gt; \u0026lt;script\u0026gt; function handleKeyDown(event) { // 判斷是否為中文輸入法並切換輸入法, 只要是中文 keyCode 都會是 229 if (event.keyCode === 229) { event.target.blur(); // 先讓輸入框失焦 setTimeout(() =\u0026gt; { event.target.focus({ preventScroll: true }); // 再重新聚焦到輸入框 }, 100); } } \u0026lt;/script\u0026gt; 可以模擬出限制使用者只能輸入英文的效果,\n但是其實瀏覽器已經不推薦使用 keyCode 去做判斷,\nkeyCode 已經被列為過時的 API.\nkey 而是應該是使用 key,\nkey 返回一個字串,\n字串就是按下的按鍵(位置),\n像是 Enter 、 a 、 1 等等\u0026hellip;\n所以如果想靠按鍵的位置直接判斷是哪一個英文就可以使用這邊的方法.\n在這裡想限制使用者輸入英文,\n且自行按下 shift 切換成英文,\n改為 key 方法可以使用:\n\u0026lt;input type=\u0026#34;text\u0026#34; onkeydown=\u0026#34;handleKeyDown(event)\u0026#34; /\u0026gt; \u0026lt;script\u0026gt; function handleKeyDown(event) { if (event.key === \u0026#34;Process\u0026#34;) { event.target.blur(); setTimeout(() =\u0026gt; { event.target.focus({ preventScroll: true }); }, 100); } } \u0026lt;/script\u0026gt; 改為使用 key 回傳的 Process 進行判斷就可以了,\nProcess 的意思就是我們 中文輸入法 會先輸入 注音,\n拚 注音 才會變成 中文字符 的過程.\nangular 再 html 的部分可以這樣寫:\n\u0026lt;input type=\u0026#34;text\u0026#34; (keydown)=\u0026#34;onlyEnKeyDown($event)\u0026#34; #inputEl /\u0026gt; 屬性綁定 keydown 事件,\n並傳入該屬性事件到我們等等要寫的方法,\n然後記得要加上 #inputEl 讓 typescript 可以用 @ViewChild 獲得該元件.\n再 typescript 的部分:\nimport { Component, ElementRef, OnInit, ViewChild } from \u0026#39;@angular/core\u0026#39;; @Component({ selector: ..., templateUrl: ..., styleUrls: [...] }) export class InputComponent implements OnInit { @ViewChild(\u0026#39;inputEl\u0026#39;) inputEl: ElementRef; constructor() { } ngOnInit(): void { } onlyEnKeyDown(event: KeyboardEvent) { if (event.key == \u0026#39;Process\u0026#39;) { this.inputEl.nativeElement.blur(); setTimeout(() =\u0026gt; { this.inputEl.nativeElement.focus(); }, 100); } } } @ViewChild 將 html 中的元素綁定到 typescript inputEl 屬性上,\n這樣就可以使用 inputEl 訪問 html 中的 input 元素,\n在 onlyEnKeyDown 方法中,\n當鍵盤事件的 key 為 Process 時,\n先用 blur() 使 input 元素失去焦點,\n再用 setTimeout() 方法,\n經過 100 毫秒後,\nfocus() 將焦點重新設回 input 元素,\n就可以達到限制英文輸入法的效果.\n","permalink":"https://www.jesseedgerunner.com/blog/blog_17/","summary":"javascript 先在 javascript 試試看吧,\n比較舊的方法是使用 keyCode 或者是 which 進行判斷,\n再來是瀏覽器建議使用的 key 方法.\nkeyCode 可以在 javascript 這樣寫:\n\u0026lt;input type=\u0026#34;text\u0026#34; onkeydown=\u0026#34;handleKeyDown(event)\u0026#34; /\u0026gt; \u0026lt;script\u0026gt; function handleKeyDown(event) { // 判斷是否為中文輸入法並切換輸入法, 只要是中文 keyCode 都會是 229 if (event.keyCode === 229) { event.target.blur(); // 先讓輸入框失焦 setTimeout(() =\u0026gt; { event.target.focus({ preventScroll: true }); // 再重新聚焦到輸入框 }, 100); } } \u0026lt;/script\u0026gt; 可以模擬出限制使用者只能輸入英文的效果,\n但是其實瀏覽器已經不推薦使用 keyCode 去做判斷,\nkeyCode 已經被列為過時的 API.\nkey 而是應該是使用 key,\nkey 返回一個字串,\n字串就是按下的按鍵(位置),\n像是 Enter 、 a 、 1 等等\u0026hellip;","title":"限定 Input Element 英文輸入法"},{"content":" Aim 這邊主要會放一些做好的 SVG 動畫, 流程大概是在 Figma 上設計完成後, 在 SVGator 使用他的 UI 進行動畫設計, 然後在本地調整 css, 將這些 SVG 動畫統一存放, 方便日後使用.\n雖然在網路上有非常多設計好的 SVG, 但是只要牽扯到動畫, 都需要 很多錢錢, 也罷, 我就自己寫吧!\n簡潔風格 ","permalink":"https://www.jesseedgerunner.com/blog/blog_16/","summary":" Aim 這邊主要會放一些做好的 SVG 動畫, 流程大概是在 Figma 上設計完成後, 在 SVGator 使用他的 UI 進行動畫設計, 然後在本地調整 css, 將這些 SVG 動畫統一存放, 方便日後使用.\n雖然在網路上有非常多設計好的 SVG, 但是只要牽扯到動畫, 都需要 很多錢錢, 也罷, 我就自己寫吧!\n簡潔風格 ","title":"SVG Animations"},{"content":" VsCode 右鍵開啟檔案或資料夾 想要在資料夾 右鍵開啟 VsCode 的功能 的話,\n需要再 安裝 的時候就勾選:\n錯過的話也別擔心,\n可以使用 Windows 註冊檔,\n首先先創建一個任何名稱都可以的 .txt,\n接著在裡面貼上下面這一段內容:\nWindows Registry Editor Version 5.00 [HKEY_CLASSES_ROOT\\*\\shell\\Open with VS Code] @=\u0026#34;Edit with VS Code\u0026#34; \u0026#34;Icon\u0026#34;=\u0026#34;C:\\\\Program Files\\\\Microsoft VS Code\\\\Code.exe,0\u0026#34; [HKEY_CLASSES_ROOT\\*\\shell\\Open with VS Code\\command] @=\u0026#34;\\\u0026#34;C:\\\\Program Files\\\\Microsoft VS Code\\\\Code.exe\\\u0026#34; \\\u0026#34;%1\\\u0026#34;\u0026#34; [HKEY_CLASSES_ROOT\\Directory\\shell\\vscode] @=\u0026#34;Open Folder as VS Code Project\u0026#34; \u0026#34;Icon\u0026#34;=\u0026#34;\\\u0026#34;C:\\\\Program Files\\\\Microsoft VS Code\\\\Code.exe\\\u0026#34;,0\u0026#34; [HKEY_CLASSES_ROOT\\Directory\\shell\\vscode\\command] @=\u0026#34;\\\u0026#34;C:\\\\Program Files\\\\Microsoft VS Code\\\\Code.exe\\\u0026#34; \\\u0026#34;%1\\\u0026#34;\u0026#34; [HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\vscode] @=\u0026#34;Open Folder as VS Code Project\u0026#34; \u0026#34;Icon\u0026#34;=\u0026#34;\\\u0026#34;C:\\\\Program Files\\\\Microsoft VS Code\\\\Code.exe\\\u0026#34;,0\u0026#34; [HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\vscode\\command] @=\u0026#34;\\\u0026#34;C:\\\\Program Files\\\\Microsoft VS Code\\\\Code.exe\\\u0026#34; \\\u0026#34;%V\\\u0026#34;\u0026#34; 最後將檔名改為 VSCodeRightClick.reg,\n然後點開檔案,\n就可以對資料夾點擊右鍵選擇使用 VsCode 開啟.\n","permalink":"https://www.jesseedgerunner.com/blog/blog_15/","summary":"VsCode 右鍵開啟檔案或資料夾 想要在資料夾 右鍵開啟 VsCode 的功能 的話,\n需要再 安裝 的時候就勾選:\n錯過的話也別擔心,\n可以使用 Windows 註冊檔,\n首先先創建一個任何名稱都可以的 .txt,\n接著在裡面貼上下面這一段內容:\nWindows Registry Editor Version 5.00 [HKEY_CLASSES_ROOT\\*\\shell\\Open with VS Code] @=\u0026#34;Edit with VS Code\u0026#34; \u0026#34;Icon\u0026#34;=\u0026#34;C:\\\\Program Files\\\\Microsoft VS Code\\\\Code.exe,0\u0026#34; [HKEY_CLASSES_ROOT\\*\\shell\\Open with VS Code\\command] @=\u0026#34;\\\u0026#34;C:\\\\Program Files\\\\Microsoft VS Code\\\\Code.exe\\\u0026#34; \\\u0026#34;%1\\\u0026#34;\u0026#34; [HKEY_CLASSES_ROOT\\Directory\\shell\\vscode] @=\u0026#34;Open Folder as VS Code Project\u0026#34; \u0026#34;Icon\u0026#34;=\u0026#34;\\\u0026#34;C:\\\\Program Files\\\\Microsoft VS Code\\\\Code.exe\\\u0026#34;,0\u0026#34; [HKEY_CLASSES_ROOT\\Directory\\shell\\vscode\\command] @=\u0026#34;\\\u0026#34;C:\\\\Program Files\\\\Microsoft VS Code\\\\Code.exe\\\u0026#34; \\\u0026#34;%1\\\u0026#34;\u0026#34; [HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\vscode] @=\u0026#34;Open Folder as VS Code Project\u0026#34; \u0026#34;Icon\u0026#34;=\u0026#34;\\\u0026#34;C:\\\\Program Files\\\\Microsoft VS Code\\\\Code.","title":"VsCode 右鍵開啟檔案"},{"content":" CI \u0026amp; CD CI \u0026amp; CD 都是軟體開發中 流程自動化 的概念.\nCI/CD 可以 加速軟體開發 與 部署流程,\n提高程式碼品質,\n降低維護成本.\n許多工具與平台如 GitHub、GitLab 等\u0026hellip;\n都提供了完整的 CI/CD 功能支援.\nCI(Continuous Integration) CI 是指在開發過程中,\n將程式碼的 修改 \u0026amp; 整合 自動化,\n讓開發者能夠頻繁地將 改變 與其他開發者所做的改變整合在一起,\n以避免後續整合時發生問題.\n可以執行如:\n程式碼自動編譯\n測試\n部署到測試環境中\n這樣可以確保程式碼的品質.\nCD(Continuous Delivery/Deployment) CD 則是指程式的 交付自動化,\n讓開發者能夠快速地將程式碼部署到正式環境中.\nCD 可以分成兩種形式:\nContinuous Delivery\n在程式碼確定能夠被部署到正式環境前, 將其部署到與正式環境相同的環境中, 並進行手動測試. Continuous Deployment\n將程式碼直接 自動部署 到正式環境中, 並不需要進行手動測試. GitHub Action GitHub Actions 是 GitHub 提供的功能,\n可以建立自動化 Workflows,\nWorkflows 存放在 Repository 中,\n可以自訂排成工作,\n當 Repository 中發生特定事件時,\n執行自動化的工作流程.\n這些事件可以是 push 、 Release 、 pull request 等\u0026hellip;\nWorkflows 可以多多套用別人寫的 actions,\n就像寫程式 import 套件一樣,\n至於每個 actions 更詳細的調控,\n可以參考他們的官方文件.\nDeploy GitHub Page 這邊是我的 Actions:\nname: Deploy GitHub Page # 這個 Action 的名稱 on: # 只有推到 main 才自動化 push: branches: - main workflow_dispatch: schedule: - cron: \u0026#34;0 16 * * *\u0026#34; # every day at midnight at UTC+8 jobs: deploy: name: Publish Content To Public Site runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 with: submodules: true # 原本的 repo 是沒有 submodule 的內容, 要記得加 token: ${{ secrets.GIT_SUBMODULE_DEPLOY_TOKEN }} # Personal access token - name: Setup Hugo uses: peaceiris/actions-hugo@v2 # 使用別人做好的 Hugo Actions with: hugo-version: \u0026#34;0.110.0\u0026#34; extended: true - name: Git Submodule Update run: | git submodule init git submodule update --remote - name: Build run: hugo --minify # 使用 Hugo 的指令 - name: Deploy uses: peaceiris/actions-gh-pages@v3 # 將檔案 commit 到網站 repo with: external_repository: jess88tw/jess88tw.github.io deploy_key: ${{ secrets.ACTIONS_DEPLOY_KEY}} # ssh Key publish_dir: ./public publish_branch: main cname: www.jesseedgerunner.com user_name: \u0026#34;github-actions[bot]\u0026#34; # 自訂 user_name user_email: \u0026#34;github-actions[bot]@users.noreply.github.com\u0026#34; Action Secrets 在上面的 action 裡,\n需要在 Action Secrets 新增 ssh private key \u0026amp; Personal access token:\n並且在 GitHub Pages Repository 的 Deploy keys 加入 public key:\n大功告成 以後只要 push 到 HUGO 的 Repository,\n就會自動執行 GitHub Action 完成自動部屬,\n直接省去每次都要在本地生成靜態網站,\n然後再 push 到靜態網站的手續,\nGitHub Action 會自動幫忙完成.🥂\n參考 GitHub Action 自動化部署 Hugo 網站\nhttps://dwye.dev/post/hugo-github-action/ actions-gh-pages\nhttps://github.com/peaceiris/actions-gh-pages ","permalink":"https://www.jesseedgerunner.com/articles/articale_15/","summary":"CI \u0026amp; CD CI \u0026amp; CD 都是軟體開發中 流程自動化 的概念.\nCI/CD 可以 加速軟體開發 與 部署流程,\n提高程式碼品質,\n降低維護成本.\n許多工具與平台如 GitHub、GitLab 等\u0026hellip;\n都提供了完整的 CI/CD 功能支援.\nCI(Continuous Integration) CI 是指在開發過程中,\n將程式碼的 修改 \u0026amp; 整合 自動化,\n讓開發者能夠頻繁地將 改變 與其他開發者所做的改變整合在一起,\n以避免後續整合時發生問題.\n可以執行如:\n程式碼自動編譯\n測試\n部署到測試環境中\n這樣可以確保程式碼的品質.\nCD(Continuous Delivery/Deployment) CD 則是指程式的 交付自動化,\n讓開發者能夠快速地將程式碼部署到正式環境中.\nCD 可以分成兩種形式:\nContinuous Delivery\n在程式碼確定能夠被部署到正式環境前, 將其部署到與正式環境相同的環境中, 並進行手動測試. Continuous Deployment\n將程式碼直接 自動部署 到正式環境中, 並不需要進行手動測試. GitHub Action GitHub Actions 是 GitHub 提供的功能,\n可以建立自動化 Workflows,\nWorkflows 存放在 Repository 中,","title":"HUGO(4) GitHub Action"},{"content":" Repository for HUGO 第一步先把本地 HUGO 靜態網站發佈到個人的 GitHub 上的 Repository,\n阿毛的習慣會設成私人,\n畢竟可能會有些草稿還沒有寫完不想發布,\n也就是 draft = true 的文件.\n建立存放 HUGO 的遠端 Repository 點選 New Repository 並填寫以下欄位:\n點選創建之後會出現:\n照著步驟在 terminal 輸入使用者相關的指令即可.\nGitHub Pages GitHub Pages 是 GitHub 提供的靜態網站托管服務,\n可以在上面部署 靜態網站,\n並且可以 自定義域名.\nRepository for Static Web Site 在 GitHub 上創建一個新 Repository,\n倉庫名必須是 username.github.io,\n其中 username 是你的 GitHub 用戶名,\n而且必須設為 Public:\n建好之後下一步就是讓 HUGO 幫我們生成靜態網站.\nHUGO Build Static Web Site 讓 HUGO 幫我們生成靜態 HTML 文件,\n在你的 HUGO 底下開啟 terminal 後輸入:\n~ % hugo --minify HUGO 會將所有的文件打包生成靜態網頁,\n並存放在 public 資料夾中.\n至於 hugo \u0026amp; hugo --minify 的區別:\nhugo =\u0026gt; 生成靜態網站.\nhugo --minify =\u0026gt; 將生成的 HTML 、 CSS 、 JavaScript 進行壓縮, 以 減小文件大小 \u0026amp; 加快頁面加載速度.\npush to .github.io 將剛剛 HUGO 幫我們打包的 public 資料夾中的 所有文件 上傳到 GitHub Repository,\n也就是剛剛的 username.github.io,\n照著提示步驟:\n接著等待 GitHub Pages 幫我們處理好一切,\n直到呈現 Active:\n就可以網址輸入 username.github.io 進入你的個人網站囉,\n以我的例子就是 https://jess88tw.github.io/.\n歡迎 donate🥤!\n購買網域 除了用 https://jess88tw.github.io/ 之外,\n也可以自己買一個網域,\n幫自己選一個喜歡的網域名稱,\n這邊我選用 Google Domain.\nGoogle Domain 至於為什麼要選用 Google Domain,\n是因為 Google Domain 提供了一些附加功能:\n郵件轉發\nWHOIS 保護\n子域名設置\n在這裡輸入想要的網域名稱:\n再來就是一系列的付款流程.\nGoogle Domain 設定 付款完成後回到 Google Domain,\n進行 DNS 資源設定,\n才可以連接到 GitHub Page.\n根據官方文件 GitHub Page 的 HTTPS 設定,\n要在 DNS 中將 base domain 設定至下列 IP：\n185.199.108.153\n185.199.109.153\n185.199.110.153\n185.199.111.153\n在 Custom resource records 中,\n選擇 resource type: A,\n並新增上述四組 IP.\n再來是 CNAME 也就是真實名稱的意思,\n作用是將個人化網域對應到真實網域,\n就像 jesseedgerunner.com 對應到 jess88tw.github.io,\n最後就會設定成這樣:\n最後讓我們把美美的個人網域 \u0026amp; GitHub Pages 進行連結吧.\nGitHub Repository 設定 前往存放網靜態網站的 Repository,\n在 Setting 第一頁找到 GitHub Pages 設定,\n然後在 custom domain 填入個人化網域 jesseedgerunner.com:\n如果無法使用 HTTPS 的話,\n是因為 Google Domain 的 DNS 設定還沒生效,\n等個幾分鐘再回來打勾就可以了.\n整理 雖然成功把網頁部屬到 GitHub Pages 了,\n但每次寫完新的文章都要再重新 hugo --minify,\n然後再重新把 public 資料夾 push 到 GitHub Pages 的 Repository 著實有點麻煩,\n在之後的章節我會介紹到 Github Action,\n他可以做到自動化部屬的功能,\n也就是 CI \u0026amp; CD.\n參考 ItHome Hugo 貼身打造個人部落格\nhttps://ithelp.ithome.com.tw/users/20106430/ironman/3613 ","permalink":"https://www.jesseedgerunner.com/articles/articale_14/","summary":"Repository for HUGO 第一步先把本地 HUGO 靜態網站發佈到個人的 GitHub 上的 Repository,\n阿毛的習慣會設成私人,\n畢竟可能會有些草稿還沒有寫完不想發布,\n也就是 draft = true 的文件.\n建立存放 HUGO 的遠端 Repository 點選 New Repository 並填寫以下欄位:\n點選創建之後會出現:\n照著步驟在 terminal 輸入使用者相關的指令即可.\nGitHub Pages GitHub Pages 是 GitHub 提供的靜態網站托管服務,\n可以在上面部署 靜態網站,\n並且可以 自定義域名.\nRepository for Static Web Site 在 GitHub 上創建一個新 Repository,\n倉庫名必須是 username.github.io,\n其中 username 是你的 GitHub 用戶名,\n而且必須設為 Public:\n建好之後下一步就是讓 HUGO 幫我們生成靜態網站.\nHUGO Build Static Web Site 讓 HUGO 幫我們生成靜態 HTML 文件,","title":"HUGO(3) GitHub Pages"},{"content":" Service 用途 Service 是可以 injectable 的一種 class,\n可以將 Angular Web App 的 業務邏輯 \u0026amp; 數據操作 Component 進行簡化.\n改由 Service 負責提供 Component 所需的邏輯 \u0026amp; 數據,\n讓 Component 可以必較容易進行數據間的溝通,\n而不需要直接進行數據操作.\n也可以將 Service 注入 Service,\n也就是所謂的 injectable.\nService 的注入 Service 可以通過注入方式在 Component 之間進行共享.\n可以使用 Dependency Injection 來實現注入.\n當一個 Component 需要使用某個 Service 的時候,\n可以在該 Component 的 constructor 中聲明一個對應的參數,\n當該 Component 被創建時,\n就可以在 Component 中呼叫該 Service 中的物件 or 方法.\nimport { Component } from \u0026#34;@angular/core\u0026#34;; // 這裡引用要使用的 Service import { MyService } from \u0026#34;./my.service\u0026#34;; @Component({ selector: \u0026#34;my-component\u0026#34;, template: \u0026#34;\u0026lt;h1\u0026gt;{{data}}\u0026lt;/h1\u0026gt;\u0026#34;, }) export class MyComponent { data: string; // 在這注入要使用的 Service constructor(private myService: MyService) { this.data = myService.getData(); } } 在上面的範例中,\nconstructor 聲明了 myService,\n從而實現了對 MyService 的注入,\n通過調用 myService 中 getData() 取得 MyService 的值.\ntodo: provider\n整理 參考 ","permalink":"https://www.jesseedgerunner.com/articles/articale_13/","summary":"Service 用途 Service 是可以 injectable 的一種 class,\n可以將 Angular Web App 的 業務邏輯 \u0026amp; 數據操作 Component 進行簡化.\n改由 Service 負責提供 Component 所需的邏輯 \u0026amp; 數據,\n讓 Component 可以必較容易進行數據間的溝通,\n而不需要直接進行數據操作.\n也可以將 Service 注入 Service,\n也就是所謂的 injectable.\nService 的注入 Service 可以通過注入方式在 Component 之間進行共享.\n可以使用 Dependency Injection 來實現注入.\n當一個 Component 需要使用某個 Service 的時候,\n可以在該 Component 的 constructor 中聲明一個對應的參數,\n當該 Component 被創建時,\n就可以在 Component 中呼叫該 Service 中的物件 or 方法.\nimport { Component } from \u0026#34;@angular/core\u0026#34;; // 這裡引用要使用的 Service import { MyService } from \u0026#34;.","title":"🚧[維修中]Angular(10) Service"},{"content":" Router 用途 Angular Router 負責管理 Angular Web App 中的不同頁面之間的 路由.\n透過 Router 模組提供了路由的機制, 讓 Angular Web App 進行 類似傳統網頁應 的導航, 但 不需要重新加載 整個應用程式.\n可以通過 RouterModule 進行自訂 \u0026amp; 訪問.\n通過設定路由規則可以讓 Angular 在特定的 URL 下載入特定 Component.\n// path 為路徑, component 決定要載入的 Component const routes: Routes = [{ path: \u0026#34;users/:id\u0026#34;, component: UserComponent }]; 整理 參考 ","permalink":"https://www.jesseedgerunner.com/articles/articale_12/","summary":" Router 用途 Angular Router 負責管理 Angular Web App 中的不同頁面之間的 路由.\n透過 Router 模組提供了路由的機制, 讓 Angular Web App 進行 類似傳統網頁應 的導航, 但 不需要重新加載 整個應用程式.\n可以通過 RouterModule 進行自訂 \u0026amp; 訪問.\n通過設定路由規則可以讓 Angular 在特定的 URL 下載入特定 Component.\n// path 為路徑, component 決定要載入的 Component const routes: Routes = [{ path: \u0026#34;users/:id\u0026#34;, component: UserComponent }]; 整理 參考 ","title":"🚧[維修中]Angular(9) Router"},{"content":" LifeCycle Hook Function 在 Angular 中,\n每個 Component \u0026amp; Directive 都有生命週期,\n其由一系列的生命週期 Hook 所組成.\nLifeCycle Hook Function 讓開發者在 Component \u0026amp; Directive 的 不同階段 做操作.\nAngular LifeCycle Hook：\nconstructor =\u0026gt; ES6 提供給 class 的建構子, 並不屬於 Angular.\nngOnChanges =\u0026gt; 當 Component 的一個 輸入屬性發生變化 時調用.\nngOnInit =\u0026gt; 當 Component 初始化完成 時調用, 此時 Component 的輸入屬性和輸出屬性都已經確定.\nngDoCheck =\u0026gt; 當 Angular 檢查 Component 的變化 時調用, 通常是由於輸入屬性發生變化或因為事件觸發引起的.\nngAfterContentInit =\u0026gt; 當 Component 的 Content 完成初始化 之後調用, 通常用於對 Component 的 Content 執行操作.\nngAfterContentChecked =\u0026gt; 當 Angular 檢查 Component 的 Content 發生變化 時調用.\nngAfterViewInit =\u0026gt; 當 Component 的 View 完成初始化 之後調用, 通常用於對 Component 的 View 執行操作.\nngAfterViewChecked =\u0026gt; 當 Angular 檢查 Component 的 View 發生變化 時調用.\nngOnDestroy =\u0026gt; 當 Component 被摧毀 時調用, 通常用於釋放 Component 所占用的資源.\n整理 可以透過實現這些 LifeCycle Hook,\n達成對 Component 進行固定的操作,\n如在 ngAfterViewInit 中可以獲取 Component 的 DOM 元素,\n在 ngOnDestroy 中可以取消 Component 所 訂閱 的資源,\n以免造成資源浪費和潛在的內存泄漏等問題.\n了解 LifeCycle Hook 的執行順序和調用時機,\n能夠更好的理解 Angular 中 Component \u0026amp; Directive 的運行機制.\n參考 ","permalink":"https://www.jesseedgerunner.com/articles/articale_11/","summary":"LifeCycle Hook Function 在 Angular 中,\n每個 Component \u0026amp; Directive 都有生命週期,\n其由一系列的生命週期 Hook 所組成.\nLifeCycle Hook Function 讓開發者在 Component \u0026amp; Directive 的 不同階段 做操作.\nAngular LifeCycle Hook：\nconstructor =\u0026gt; ES6 提供給 class 的建構子, 並不屬於 Angular.\nngOnChanges =\u0026gt; 當 Component 的一個 輸入屬性發生變化 時調用.\nngOnInit =\u0026gt; 當 Component 初始化完成 時調用, 此時 Component 的輸入屬性和輸出屬性都已經確定.\nngDoCheck =\u0026gt; 當 Angular 檢查 Component 的變化 時調用, 通常是由於輸入屬性發生變化或因為事件觸發引起的.\nngAfterContentInit =\u0026gt; 當 Component 的 Content 完成初始化 之後調用, 通常用於對 Component 的 Content 執行操作.","title":"🚧[維修中]Angular(8) LifeCycle"},{"content":" Pipe 用途 Angular 的 Pipe 是一種 轉換資料 的方式,\n它可以用在 Template 中對資料進行格式化或轉換等操作,\n並可以在程式碼中進行重複利用.\nPipe 可以分為兩種類型:\nAngular 內建 Pipe, Angular 提供如 DatePipe 、 UpperCasePipe\u0026hellip;\n自訂 Pipe.\n內建 Pipe 只需要在模板中使用管道符號 | 來調用 Pipe 即可.\n以下是一些常用的內建 Pipe:\nDatePipe =\u0026gt; 格式化日期, {{ date | date:'yyyy-MM-dd' }}\nUpperCasePipe =\u0026gt; 將文字轉為大寫, {{ name | uppercase }}\nLowerCasePipe =\u0026gt; 將文字轉為小寫, {{ name | lowercase }}\nCurrencyPipe =\u0026gt; 格式化金額, {{ price | currency:'USD' }}\nPercentPipe =\u0026gt; 格式化百分比, {{ rate | percent }}\nAsyncPipe =\u0026gt; 處理非同步資料, {{ data$ | async }}\n自訂 Pipe 可以自行撰寫 Pipe,\n擴充 Angular 的 Pipe 功能,\n需要實作 PipeTransform Interface,\n該介面只有一個 transform 方法, 負責處理資料轉換.\n以下是一個自訂的 Pipe 範例：\nimport { Pipe, PipeTransform } from \u0026#34;@angular/core\u0026#34;; // Pipe 裝飾器 @Pipe({ name: \u0026#34;double\u0026#34;, }) // 實作 PipeTransform Interface export class DoublePipe implements PipeTransform { transform(value: number): number { return value * 2; } } 上面的範例是一個名為 double 的 Pipe,\n當我們在 Template 中使用 {{ number | double }},\n該 Pipe 會將數字乘以 2 後再輸出.\n整理 參考 ","permalink":"https://www.jesseedgerunner.com/articles/articale_10/","summary":"Pipe 用途 Angular 的 Pipe 是一種 轉換資料 的方式,\n它可以用在 Template 中對資料進行格式化或轉換等操作,\n並可以在程式碼中進行重複利用.\nPipe 可以分為兩種類型:\nAngular 內建 Pipe, Angular 提供如 DatePipe 、 UpperCasePipe\u0026hellip;\n自訂 Pipe.\n內建 Pipe 只需要在模板中使用管道符號 | 來調用 Pipe 即可.\n以下是一些常用的內建 Pipe:\nDatePipe =\u0026gt; 格式化日期, {{ date | date:'yyyy-MM-dd' }}\nUpperCasePipe =\u0026gt; 將文字轉為大寫, {{ name | uppercase }}\nLowerCasePipe =\u0026gt; 將文字轉為小寫, {{ name | lowercase }}\nCurrencyPipe =\u0026gt; 格式化金額, {{ price | currency:'USD' }}\nPercentPipe =\u0026gt; 格式化百分比, {{ rate | percent }}","title":"🚧[維修中]Angular(7) Pipe"},{"content":" Directive 用途 Angular Directive 是用來擴充 HTML 的元素 、 屬性 、 class 、 樣式,\n可以透過 Directive 自定義 HTML 元素的行為 \u0026amp; 樣式.\nAngular 有三種 Directive:\nComponent Directive, 用來構建可重複使用的 Component.\nAttribute Directive, 用來更改元素的外觀 \u0026amp; 行為.\nStructural Directive, 用來改變 HTML 的 布局 、 結構.\nComponent Directive 可以把 Component Directive 當作是一個帶有 模板 的指令,\n用來構建 可重複使用的 \u0026amp; 有模板的元件,\n它可以與其它 Directive 、 元素 、 屬性一起使用.\nAttribute Directive Attribute Directive 可以修改 HTML 元素的 外觀 \u0026amp; 行為,\n在 Angular 中,\n有提供內建的 Attribute Directive:\nngClass\nngStyle\nStructural Directive Structural Directive 可以改變 HTML 的布局 \u0026amp; 結構.\n可以用來 添加 、 刪除 、 替換 DOM 元素,\n從而改變 DOM 結構本身.\nAngular 提供了三種內置 Structural Directive:\n*ngIf =\u0026gt; 用於判斷之後, 顯示或隱藏一個元素.\n*ngFor =\u0026gt; 用於對集合進行迴圈.\n[ngSwitch] =\u0026gt; 用於根據表達式的值, 顯示或隱藏多個元素之一.\n整理 參考 ","permalink":"https://www.jesseedgerunner.com/articles/articale_09/","summary":"Directive 用途 Angular Directive 是用來擴充 HTML 的元素 、 屬性 、 class 、 樣式,\n可以透過 Directive 自定義 HTML 元素的行為 \u0026amp; 樣式.\nAngular 有三種 Directive:\nComponent Directive, 用來構建可重複使用的 Component.\nAttribute Directive, 用來更改元素的外觀 \u0026amp; 行為.\nStructural Directive, 用來改變 HTML 的 布局 、 結構.\nComponent Directive 可以把 Component Directive 當作是一個帶有 模板 的指令,\n用來構建 可重複使用的 \u0026amp; 有模板的元件,\n它可以與其它 Directive 、 元素 、 屬性一起使用.\nAttribute Directive Attribute Directive 可以修改 HTML 元素的 外觀 \u0026amp; 行為,\n在 Angular 中,","title":"🚧[維修中]Angular(6) Directive"},{"content":" Data Binding 用途 Angular 的 Data Binding 可以幫助我們將應用程式的資料和 DOM 建立關聯,\n實現動態資料更新 DOM 的效果.\nAngular Data Binding 主要有四種形式:\n插值綁定(Interpolation)\n屬性綁定(Property Binding)\n事件綁定(Event Binding)\n雙向綁定(Two-way Binding)\nData Binding 優點 更加輕鬆地將 Component 與 Template 建立關聯.\n提高開發效率 \u0026amp; 可維護性.\nAngular 變更偵測機制 可以實現高效的資料更新, 避免不必要的 DOM 操作.\nInterpolation 使用 {{ }} 語法將資料綁定到 Template,\n通常用於將資料顯示在標題 \u0026amp; 段落或表格等元素中.\n\u0026lt;h1\u0026gt;{{ title }}\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;{{ content }}\u0026lt;/p\u0026gt; Property Binding 使用 [ ] 語法將資料綁定到元素的 屬性 上,\n通常用於修改元素的屬性值,\n例如修改按鈕的文字 \u0026amp;　圖片的 URL 等\u0026hellip;\n\u0026lt;!-- 控制按鈕可不可以按的屬性 --\u0026gt; \u0026lt;button [disabled]=\u0026#34;isDisabled\u0026#34;\u0026gt;{{ buttonLabel }}\u0026lt;/button\u0026gt; \u0026lt;!-- 綁定圖片 URL 屬性 --\u0026gt; \u0026lt;img [src]=\u0026#34;imageUrl\u0026#34; alt=\u0026#34;Angular Logo\u0026#34; /\u0026gt; Event Binding 使用 ( ) 語法將元素的 事件 綁定到組件中的 方法 上,\n通常用於 觸發特定的行為,\n例如點擊按鈕時執行某個方法.\n\u0026lt;button (click)=\u0026#34;onClick()\u0026#34;\u0026gt;Click me!\u0026lt;/button\u0026gt; Two-way Binding 使用 [( )] 語法將元素的 屬性 \u0026amp; 事件 綁定到組件中的資料上,\n實現資料的雙向同步.\n\u0026lt;!-- [(ngModel)] 是 Angular 中用來實現雙向資料綁定的指令--\u0026gt; \u0026lt;input [(ngModel)]=\u0026#34;username\u0026#34; /\u0026gt; 整理 參考 ","permalink":"https://www.jesseedgerunner.com/articles/articale_08/","summary":"Data Binding 用途 Angular 的 Data Binding 可以幫助我們將應用程式的資料和 DOM 建立關聯,\n實現動態資料更新 DOM 的效果.\nAngular Data Binding 主要有四種形式:\n插值綁定(Interpolation)\n屬性綁定(Property Binding)\n事件綁定(Event Binding)\n雙向綁定(Two-way Binding)\nData Binding 優點 更加輕鬆地將 Component 與 Template 建立關聯.\n提高開發效率 \u0026amp; 可維護性.\nAngular 變更偵測機制 可以實現高效的資料更新, 避免不必要的 DOM 操作.\nInterpolation 使用 {{ }} 語法將資料綁定到 Template,\n通常用於將資料顯示在標題 \u0026amp; 段落或表格等元素中.\n\u0026lt;h1\u0026gt;{{ title }}\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;{{ content }}\u0026lt;/p\u0026gt; Property Binding 使用 [ ] 語法將資料綁定到元素的 屬性 上,\n通常用於修改元素的屬性值,\n例如修改按鈕的文字 \u0026amp;　圖片的 URL 等\u0026hellip;","title":"🚧[維修中]Angular(5) Data Binding"},{"content":" Component 用途 Component 用於控制網頁視圖中的 一塊區域.\n渲染, 透過 HTML \u0026amp; CSS.\n資料該怎麼顯示, DOM 如何被操作, 透過 TS.\n資料改怎麼傳遞, 透過 Data Binding or TS 中的 Service.\n在 Component 中可以包含其他的 Component.\n因此好的 Component 必須可以 重複使用.\n建立新 Component 於 terminal 輸入 ng g c board 生成一個 board Component.\nPS C:\\Users\\Jess\\Test\u0026gt; ng g c board CREATE src/app/board/board.component.html (20 bytes) CREATE src/app/board/board.component.spec.ts (592 bytes) CREATE src/app/board/board.component.ts (198 bytes) CREATE src/app/board/board.component.css (0 bytes) UPDATE src/app/app.module.ts (447 bytes) 在這裡 Angular CLI 幫我們建立了一個資料夾 board.\n點進可以看到 Angular CLI 幫我們建立了四個檔案:\nboard.component.css\nboard.component.html\nboard.component.ts\nboard.component.spec.ts\n接著看到 board.component.ts:\nimport { Component } from \u0026#34;@angular/core\u0026#34;; @Component({ selector: \u0026#34;app-board\u0026#34;, templateUrl: \u0026#34;./board.component.html\u0026#34;, styleUrls: [\u0026#34;./board.component.css\u0026#34;], }) export class BoardComponent {} 觀察到 selector: \u0026quot;app-board\u0026quot;,\napp-board 即是之後可以放入父類 Component 的 Tag 標籤 .\n在看到 app.module.ts:\nimport { NgModule } from \u0026#34;@angular/core\u0026#34;; import { BrowserModule } from \u0026#34;@angular/platform-browser\u0026#34;; import { AppRoutingModule } from \u0026#34;./app-routing.module\u0026#34;; import { AppComponent } from \u0026#34;./app.component\u0026#34;; // Angular CLI 已經自動幫我們引用了 BoardComponent import { BoardComponent } from \u0026#34;./board/board.component\u0026#34;; @NgModule({ // 這邊也要記得匯入 declarations: [AppComponent, BoardComponent], imports: [BrowserModule, AppRoutingModule], providers: [], bootstrap: [AppComponent], }) export class AppModule {} 可以發現 Angular CLI 於 app.module.ts 中註冊了新增的 BoardComponent.\n再到 app.component.html, 將原本的內容通通刪掉, 修改為:\n\u0026lt;app-board\u0026gt;\u0026lt;/app-board\u0026gt; 再次以瀏覽器開啟可看到 board.componet.html 裡面的內容.\nComponent 的重複性 接下來輸入 ng g c card 生成第二個 Component.\n把 card.component.html, 修改成:\n\u0026lt;div class=\u0026#34;card\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h4\u0026gt;\u0026lt;strong\u0026gt;Cake\u0026lt;/strong\u0026gt;\u0026lt;/h4\u0026gt; \u0026lt;p\u0026gt;This is a cake.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 把 card.component.css, 修改成:\n* { margin: 0; padding: 0; font-family: sans-serif; background-color: coral; } .card { border: 3px solid #fff; border-radius: 9px; box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2); display: flex; align-items: center; justify-content: center; transition: all 0.3s; } .card:hover { box-shadow: 0 12px 16px 0 rgba(0, 0, 0, 0.2); } .container { margin: 16px 16px; width: 100%; display: flex; flex-direction: column; justify-content: center; gap: 20px; color: #333; } h4 { font-size: 24px; } p { font-size: 18px; } 於 board.component.html, 修改為:\n\u0026lt;app-card\u0026gt;\u0026lt;/app-card\u0026gt; 可以發現剛才設計的 card 出現在我們畫面上了.\n現在我們把 board.component.html, 修改為:\n\u0026lt;app-card\u0026gt;\u0026lt;/app-card\u0026gt; \u0026lt;app-card\u0026gt;\u0026lt;/app-card\u0026gt; \u0026lt;app-card\u0026gt;\u0026lt;/app-card\u0026gt; 畫面變為三張 card.\n可以了解到 Component 是可以被 重複使用的.\n整理 目前 AppComponent Template 裡擁有一個 BoardComponent,\nBoardComponent Template 裡面擁有三個 CardComponent,\n由此發現 Component 裡面可以含有其他的 Componet,\n因此設計 Angular 的頁面主要是在設計 Componet, 再將各個 Componet 組合在一起,\n到目前為止, 我們已經了解到如何設計一個 Component 的 HTML \u0026amp; CSS.\n接下來我們必須要將其與 TypeScript 連結, 才能讓這些 DOM 與資料動起來.\n參考 原味英雄之旅!\nhttps://angular.io/ ","permalink":"https://www.jesseedgerunner.com/articles/articale_07/","summary":"Component 用途 Component 用於控制網頁視圖中的 一塊區域.\n渲染, 透過 HTML \u0026amp; CSS.\n資料該怎麼顯示, DOM 如何被操作, 透過 TS.\n資料改怎麼傳遞, 透過 Data Binding or TS 中的 Service.\n在 Component 中可以包含其他的 Component.\n因此好的 Component 必須可以 重複使用.\n建立新 Component 於 terminal 輸入 ng g c board 生成一個 board Component.\nPS C:\\Users\\Jess\\Test\u0026gt; ng g c board CREATE src/app/board/board.component.html (20 bytes) CREATE src/app/board/board.component.spec.ts (592 bytes) CREATE src/app/board/board.component.ts (198 bytes) CREATE src/app/board/board.component.css (0 bytes) UPDATE src/app/app.module.ts (447 bytes) 在這裡 Angular CLI 幫我們建立了一個資料夾 board.","title":"🚧[維修中]Angular(4) Component"},{"content":" What is NgModule? Angular 的特點之一就是 模組化開發的框架, 它有著自己特有的模組系統 NgModule.\n每個 Angular App 至少會有一個 NgModule 的 Root Module, 通常取名為 AppModule, 且這個根模組會放在 app.module.ts.\n解析 app.module.ts:\n// import 的程式碼都放在這個區塊 import { NgModule } from \u0026#34;@angular/core\u0026#34;; import { BrowserModule } from \u0026#34;@angular/platform-browser\u0026#34;; import { AppRoutingModule } from \u0026#34;./app-routing.module\u0026#34;; import { AppComponent } from \u0026#34;./app.component\u0026#34;; // Decorator 裝飾器 @NgModule({ declarations: [AppComponent], imports: [BrowserModule, AppRoutingModule], providers: [], bootstrap: [AppComponent], }) export class AppModule {} @NgModule:\ndeclarations =\u0026gt; 可以放入 Component, Directive, Pipe.\nimports =\u0026gt; 可以放入此 NgModule 需要使用 \u0026amp; 依賴的其他 NgModule.\nproviders =\u0026gt; 可以放入 全域使用的 Service.\nbootstrap =\u0026gt; 則是決定進入點要使用哪一個 Component, 預設使用 AppComponent.\nWhat is Component? Component 負責 定義 \u0026amp; 控制畫面, 讓 Angular 可以根據資料和程式邏輯呈現相對應的畫面, 通常由四個檔案組成一個 Component.\nComponent:\n.component.css =\u0026gt; 用於定義該元件的 CSS 樣式.\n.component.html =\u0026gt; 作為該元件範本的 HTML 檔案.\n.component.ts =\u0026gt; 存放該元件類別 Component 的 TypeScript 檔案.\n.component.spec.ts =\u0026gt; 用於單元測試.\n解析 app.component.ts:\n// import 的程式碼都放在這個區塊 import { Component } from \u0026#34;@angular/core\u0026#34;; // Decorator 裝飾器 @Component({ selector: \u0026#34;app-root\u0026#34;, templateUrl: \u0026#34;./app.component.html\u0026#34;, styleUrls: [\u0026#34;./app.component.css\u0026#34;], }) export class AppComponent { title = \u0026#34;Test\u0026#34;; } @Component:\nselector =\u0026gt; CSS 選擇器\n它告訴 Angular 在 Template 中找到相應的位置之後, 創建並插入該 Component 實體.\n以上述為例, 在 HTML 中我們可以使用 \u0026lt;app-root\u0026gt;\u0026lt;/app-root\u0026gt; 來顯示該 Component 的內容.\ntemplateUrl =\u0026gt; 此 Component 的 Template 檔案位置(相對位置).\ntemplate =\u0026gt; 與 templateUrl 的用途類似, 但這裡是直接放 HTML 的語法(不建議使用).\nstyleUrls =\u0026gt; 樣式檔檔案位置(相對位置).\nstyles =\u0026gt; 與 styleUrls 類似, 但這裡可以直接放 CSS 的語法(不建議使用).\nproviders =\u0026gt; 與 NgModule 的 providers 類似, 但作用區域不同.\nWhat is Template? Template 是由 HTML + CSS 再加上一些 Angular 提供的 符號 \u0026amp; 屬性 所組成.\nTemplate 上的 元素 \u0026amp; 資料 都是靜態的, 搭配 Component 裡的 TypeScript 即可控制 Template 中要顯示的內容.\nSingle Page Application Angular 的架構是一個 SPA 單頁應用, 起始頁為 index.html\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Test\u0026lt;/title\u0026gt; \u0026lt;base href=\u0026#34;/\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;icon\u0026#34; type=\u0026#34;image/x-icon\u0026#34; href=\u0026#34;favicon.ico\u0026#34; /\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 插入 Component 在這裡 --\u0026gt; \u0026lt;app-root\u0026gt;\u0026lt;/app-root\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 在 index.html 中, 可以看到這裡定義了一些常見的 html 標籤.\n可以注意到在 \u0026lt;body\u0026gt;\u0026lt;/body\u0026gt; 裡面, 放著 AppComponent 的選擇器標籤.\n因此當進入 index.html 時, \u0026lt;body\u0026gt;\u0026lt;/body\u0026gt; 中的 \u0026lt;app-root\u0026gt;\u0026lt;/app-root\u0026gt; 會被替換成 AppComponent 內容.\nAppComponent 的內容便是 templateUrl + styleUrls + ts 所組成的畫面.\n接著看到 angular.json:\n{ \u0026#34;$schema\u0026#34;: \u0026#34;./node_modules/@angular/cli/lib/config/schema.json\u0026#34;, \u0026#34;version\u0026#34;: 1, \u0026#34;newProjectRoot\u0026#34;: \u0026#34;projects\u0026#34;, \u0026#34;projects\u0026#34;: { \u0026#34;Test\u0026#34;: { \u0026#34;projectType\u0026#34;: \u0026#34;application\u0026#34;, \u0026#34;schematics\u0026#34;: {}, \u0026#34;root\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;sourceRoot\u0026#34;: \u0026#34;src\u0026#34;, \u0026#34;prefix\u0026#34;: \u0026#34;app\u0026#34;, \u0026#34;architect\u0026#34;: { \u0026#34;build\u0026#34;: { \u0026#34;builder\u0026#34;: \u0026#34;@angular-devkit/build-angular:browser\u0026#34;, \u0026#34;options\u0026#34;: { \u0026#34;outputPath\u0026#34;: \u0026#34;dist/test\u0026#34;, // 這裡定義了起始頁面 \u0026#34;index\u0026#34;: \u0026#34;src/index.html\u0026#34;, // 這裡定義了起始的ts執行檔 \u0026#34;main\u0026#34;: \u0026#34;src/main.ts\u0026#34;, \u0026#34;polyfills\u0026#34;: [\u0026#34;zone.js\u0026#34;], \u0026#34;tsConfig\u0026#34;: \u0026#34;tsconfig.app.json\u0026#34;, \u0026#34;assets\u0026#34;: [\u0026#34;src/favicon.ico\u0026#34;, \u0026#34;src/assets\u0026#34;], \u0026#34;styles\u0026#34;: [\u0026#34;src/styles.css\u0026#34;], \u0026#34;scripts\u0026#34;: [] }, . . . 在 angular.json 中:\nIndex: src/index.html =\u0026gt; 決定 index.html 為起始頁面也是唯一頁面.\nmain: src/main.ts =\u0026gt; 決定 main.ts 為起始的 ts 執行檔.\n再來看到 main.ts:\nimport { platformBrowserDynamic } from \u0026#34;@angular/platform-browser-dynamic\u0026#34;; import { AppModule } from \u0026#34;./app/app.module\u0026#34;; platformBrowserDynamic() .bootstrapModule(AppModule) .catch((err) =\u0026gt; console.error(err)); main.ts 透過 bootstrapModule 啟動 AppModule.\n運作流程:\nindex.html =\u0026gt; main.ts =\u0026gt; app.module.ts =\u0026gt; app.component.ts 參考 Angular 深入淺出三十天\nhttps://ithelp.ithome.com.tw/users/20090728/ironman/1600 ","permalink":"https://www.jesseedgerunner.com/articles/articale_06/","summary":"What is NgModule? Angular 的特點之一就是 模組化開發的框架, 它有著自己特有的模組系統 NgModule.\n每個 Angular App 至少會有一個 NgModule 的 Root Module, 通常取名為 AppModule, 且這個根模組會放在 app.module.ts.\n解析 app.module.ts:\n// import 的程式碼都放在這個區塊 import { NgModule } from \u0026#34;@angular/core\u0026#34;; import { BrowserModule } from \u0026#34;@angular/platform-browser\u0026#34;; import { AppRoutingModule } from \u0026#34;./app-routing.module\u0026#34;; import { AppComponent } from \u0026#34;./app.component\u0026#34;; // Decorator 裝飾器 @NgModule({ declarations: [AppComponent], imports: [BrowserModule, AppRoutingModule], providers: [], bootstrap: [AppComponent], }) export class AppModule {} @NgModule:\ndeclarations =\u0026gt; 可以放入 Component, Directive, Pipe.","title":"🚧[維修中]Angular(3) 基礎結構"},{"content":" Visual Studio Code IDE 推薦使用 Visual Studio Code.\nVs code Extensions 安裝 Angular Extension Pack.\n前往 Visual Studio Code 官網 =====\u0026gt; https://code.visualstudio.com/\n安裝 NodeJS 安裝 NodeJS LTS 版本.\n於環境變數中的 Path, 新增 nodejs 的安裝路徑.\n前往 NodeJS 官網 =====\u0026gt; https://nodejs.org/en/\n在 terminal 輸入 node -v, 測試 nodejs 確認安裝是否成功.\n$ node -v v18.16.0 安裝 Angular CLI 輸入 npm install -g @angular/cli,\n再輸入 ng version 測試 Angular CLI 確認安裝是否成功.\n$ ng version _ _ ____ _ ___ / \\ _ __ __ _ _ _| | __ _ _ __ / ___| | |_ _| / △ \\ | \u0026#39;_ \\ / _` | | | | |/ _` | \u0026#39;__| | | | | | | / ___ \\| | | | (_| | |_| | | (_| | | | |___| |___ | | /_/ \\_\\_| |_|\\__, |\\__,_|_|\\__,_|_| \\____|_____|___| |___/ Angular CLI: 16.0.1 Node: 18.16.0 Package Manager: npm 9.6.6 OS: darwin x64 Angular: ... Package Version ------------------------------------------------------ @angular-devkit/architect 0.1600.1 (cli-only) @angular-devkit/core 16.0.1 (cli-only) @angular-devkit/schematics 16.0.1 (cli-only) @schematics/angular 16.0.1 (cli-only) Angular CLI 可輸入 ng help 查詢其所提供的指令.\n比較常用到的指令:\n建立新專案: ng new \u0026lt;app 的名稱\u0026gt;.\n建立 component: ng g c \u0026lt;component 的名稱\u0026gt;.\n建立 service: ng g s \u0026lt;service 的名稱\u0026gt;.\n建立 module: ng g m \u0026lt;module 的名稱\u0026gt;.\n建立 directive: ng g d \u0026lt;directive 的名稱\u0026gt;.\n建立 pipe: ng g p \u0026lt;pipe 的名稱\u0026gt;.\n建立 guard: ng g g \u0026lt;guard 的名稱\u0026gt;.\n建立 class: ng g cl \u0026lt;class 的名稱\u0026gt;.\n建立 interface: ng g i \u0026lt;interface 的名稱\u0026gt;.\n建立 enum: ng g e \u0026lt;enum 的名稱\u0026gt;.\n建置專案: ng build.\n啟動專案: ng serve.\nAngular CLI Options 可以在指令後加上 Options,\n項是 ng new \u0026lt;app 的名稱\u0026gt; --routing --style-scss --skip-git --skip-install --skip-tests.\n常用到的 Options:\n-\n--routing: 使用路由模組, 會建立 app-routing.module.ts.\n--dry-run: 執行前先模擬, 不會真的建立檔案.\n--skip-git: 不會建立 git 相關檔案.\nskip-install: 不會安裝 npm 套件.\nskip-tests: 不會建立測試檔案.\nskip-e2e: 不會建立 e2e 測試檔案.\n--style-scss: 使用 scss 樣式.\n--directory: 指定建立專案的目錄.\n建立新專案 在 terminal 輸入 ng new Test:\n$ ng new Test ? Would you like to add Angular routing? Yes ? Which stylesheet format would you like to use? CSS CREATE Test/angular.json (2690 bytes) CREATE Test/package.json (1035 bytes) . . . Successfully initialized git. IDE 開啟專案,\nIDE terminal 輸入 ng serve,\n第一次啟動編譯時間會較長一些,\nServer 預設啟動在 4200 Port.\n參考 更多 Angular CLI 介紹\nhttps://medium.com/@sky22357168/angular-cli-%E4%BB%8B%E7%B4%B9-56390b80cab0 ","permalink":"https://www.jesseedgerunner.com/articles/articale_05/","summary":"Visual Studio Code IDE 推薦使用 Visual Studio Code.\nVs code Extensions 安裝 Angular Extension Pack.\n前往 Visual Studio Code 官網 =====\u0026gt; https://code.visualstudio.com/\n安裝 NodeJS 安裝 NodeJS LTS 版本.\n於環境變數中的 Path, 新增 nodejs 的安裝路徑.\n前往 NodeJS 官網 =====\u0026gt; https://nodejs.org/en/\n在 terminal 輸入 node -v, 測試 nodejs 確認安裝是否成功.\n$ node -v v18.16.0 安裝 Angular CLI 輸入 npm install -g @angular/cli,\n再輸入 ng version 測試 Angular CLI 確認安裝是否成功.\n$ ng version _ _ ____ _ ___ / \\ _ __ __ _ _ _| | __ _ _ __ / ___| | |_ _| / △ \\ | \u0026#39;_ \\ / _` | | | | |/ _` | \u0026#39;__| | | | | | | / ___ \\| | | | (_| | |_| | | (_| | | | |___| |___ | | /_/ \\_\\_| |_|\\__, |\\__,_|_|\\__,_|_| \\____|_____|___| |___/ Angular CLI: 16.","title":"🚧[維修中]Angular(2) 環境安裝"},{"content":" What? Angular 是一個開源的前端框架,\n由 Google 團隊開發和維護,\n跟之前介紹的靜態網頁 Hugo 不同,\n用於構建 動態 Web App.\n有完整的開發工具包,\n讓開發者可以更加快速與高效地開發 Web App.\nWhy? 企業級前端框架(Enterprise-grade Frontend Framework)\n使用強型別的 TypeScript 程式語言\n使用以類別為基礎的物件導向架構開發 Web App\n超高生產力(Super High Productivity)\nAngular CLI 改善開發流程\n內建 codelyzer 靜態程式碼分析工具確保開發品質\n穩定的版本升級策略\n擁有穩定的 Angular 版本與釋出政策\n每個版本升級皆可搭配 ng update 自動更新\nFeatures Angular 擁有許多特色, 以下列出幾個主要的特色.\nData Binding Component(ts) \u0026amp; Template(HTML) 互相傳遞資料的方式,\n減少了手動處理 DOM 的繁雜工作,\n提高了開發效率.\n模組化架構 將 Web App 拆分為多個模塊,\n每個模塊專注於一個特定的功能,\n提高程式的 可維護性 和 可擴展性.\nDependency injection Angular 提供了依賴注入的機制,\n可以創建可 重用 \u0026amp; 可 測試 的 Component,\n減少程式的重工.\nDirectives Directives 可以幫助開發者更輕鬆地實現各種常見 DOM 操作.\n*ngFor\n*ngIf\n[ngSwitch]\nTypescript Angular 使用 TypeScript 作為開發語言.\n擁有 型別 與 介面\n提供 提示 和 錯誤檢查機制, 減少出錯.\nAngular CLI Angular CLI 是一個命令行工具,\n可以幫助開發者快速建立 Angular 專案,\n並提供了許多實用的指令.\nAngular vs Java 大概了解 Angular 的特色後,\n來建立第一個 Angular App,\n以及進一步了解他吧!\n參考 原味英雄之旅!\nhttps://angular.io/ Angular 中文官網\nhttps://angular.tw/ TypeScript 新手指南\nhttps://willh.gitbook.io/typescript-tutorial/ RxJS 中文版\nhttps://rxjs.angular.tw Angular Material 元件庫\nhttps://material.angular.tw ","permalink":"https://www.jesseedgerunner.com/articles/articale_04/","summary":"What? Angular 是一個開源的前端框架,\n由 Google 團隊開發和維護,\n跟之前介紹的靜態網頁 Hugo 不同,\n用於構建 動態 Web App.\n有完整的開發工具包,\n讓開發者可以更加快速與高效地開發 Web App.\nWhy? 企業級前端框架(Enterprise-grade Frontend Framework)\n使用強型別的 TypeScript 程式語言\n使用以類別為基礎的物件導向架構開發 Web App\n超高生產力(Super High Productivity)\nAngular CLI 改善開發流程\n內建 codelyzer 靜態程式碼分析工具確保開發品質\n穩定的版本升級策略\n擁有穩定的 Angular 版本與釋出政策\n每個版本升級皆可搭配 ng update 自動更新\nFeatures Angular 擁有許多特色, 以下列出幾個主要的特色.\nData Binding Component(ts) \u0026amp; Template(HTML) 互相傳遞資料的方式,\n減少了手動處理 DOM 的繁雜工作,\n提高了開發效率.\n模組化架構 將 Web App 拆分為多個模塊,\n每個模塊專注於一個特定的功能,\n提高程式的 可維護性 和 可擴展性.\nDependency injection Angular 提供了依賴注入的機制,","title":"Angular(1) 簡介"},{"content":" Spread Operator 在 JavaScript, Spread operator 是一個用來展開 array or object 的運算符號, 可以分解成單獨的元素,可以分解成單獨的元素, 讓它們可以被傳遞到函式或者陣列中, 好處是可以簡化程式碼, 使其簡潔易讀.\nSpread operator 使用三個點 ... 來表示.\n展開陣列 const arr1 = [1, 2, 3]; const arr2 = [...arr1, 4, 5, 6]; console.log(arr2); // [1, 2, 3, 4, 5, 6] 將兩個陣列合併 const arr1 = [1, 2, 3]; const arr2 = [4, 5, 6]; const arr3 = [...arr1, ...arr2]; console.log(arr3); // [1, 2, 3, 4, 5, 6] 在函式中傳遞陣列 function myFunction(x, y, z) { console.log(x + y + z); } const arr = [1, 2, 3]; myFunction(...arr); // 6 複製陣列 const arr1 = [1, 2, 3]; const arr2 = [...arr1]; console.log(arr2); // [1, 2, 3] 展開物件 const obj1 = { a: 1, b: 2 }; const obj2 = { ...obj1, c: 3 }; console.log(obj2); // { a: 1, b: 2, c: 3 } 將原物件屬性取代為新值 const obj1 = { a: 1, b: 2 }; const obj2 = { ...obj1, a: 3 }; console.log(obj2); // { a: 3, b: 2 } ","permalink":"https://www.jesseedgerunner.com/blog/blog_14/","summary":"Spread Operator 在 JavaScript, Spread operator 是一個用來展開 array or object 的運算符號, 可以分解成單獨的元素,可以分解成單獨的元素, 讓它們可以被傳遞到函式或者陣列中, 好處是可以簡化程式碼, 使其簡潔易讀.\nSpread operator 使用三個點 ... 來表示.\n展開陣列 const arr1 = [1, 2, 3]; const arr2 = [...arr1, 4, 5, 6]; console.log(arr2); // [1, 2, 3, 4, 5, 6] 將兩個陣列合併 const arr1 = [1, 2, 3]; const arr2 = [4, 5, 6]; const arr3 = [...arr1, ...arr2]; console.log(arr3); // [1, 2, 3, 4, 5, 6] 在函式中傳遞陣列 function myFunction(x, y, z) { console.","title":"JavaScript Spread Operator 用法"},{"content":" find() 方法 用法: array.find(callback[, thisArg])\n功能: 尋找符合指定條件的 第一個元素, 如果找到則返回該元素, 否則返回 undefined.\ncallback:\n接受 3 個參數:\nelement: 當前遍歷到的陣列元素.\nindex(可選): 當前遍歷到的陣列元素的索引.\narray(可選): 被遍歷的陣列.\n返回值: 如果符合指定條件, 則返回 true, 否則返回 false.\nfind() 範例 const arr = [1, 2, 3, 4, 5]; const result = arr.find((num) =\u0026gt; num \u0026gt; 3); console.log(result); // 4 (num) =\u0026gt; num \u0026gt; 3 是回調函數, 用來判斷陣列中的每個元素是否大於 3, 當 第一個 符合條件的元素被找到時, 該元素就會成為 find() 方法的返回值.\nnum 是當前遍歷到的陣列元素.\nnum \u0026gt; 3 表示判斷當前的元素是否大於 3.\nreduce() 方法 用法: array.reduce(callback[, initialValue])\n功能: 對陣列中的所有元素進行累加計算, 返回計算結果.\ncallback:\n接受 4 個參數:\naccumulator: 上一次調用回調函數時返回的累積值或初始值.\ncurrentValue: 當前遍歷到的陣列元素.\nindex(可選): 當前遍歷到的陣列元素的索引.\narray(可選): 被計算的陣列.\n返回值: 返回計算結果.\nreduce() 範例 const arr = [1, 2, 3, 4, 5]; const result = arr.reduce((sum, num) =\u0026gt; sum + num, 0); console.log(result); // 15 (sum, num) =\u0026gt; sum + num 是回調函數, 用來將陣列中的每個元素與之前的累加值相加, 得到新的累加值.\nsum 是上一次回調函數返回的累加值, 初始值為 0.\nnum 是當前遍歷到的陣列元素.\nsum + num 表示將上一次的累加值 sum 和當前的元素值 num 相加.\n0 是 reduce() 方法的第二個參數, 表示初始值. 因為第一次調用回調函數時, 上一次的累加值為初始值, 而 不是陣列的第一個元素.\n差異 find() 方法尋找符合指定條件的第一個元素, 而 reduce() 方法對陣列中的所有元素進行累加計算.\nfind() 方法的回調函數返回布爾值, 而 reduce() 方法的回調函數返回計算結果.\nfind() 方法返回找到的元素, 如果沒有找到則返回 undefined, 而 reduce() 方法返回計算結果.\n","permalink":"https://www.jesseedgerunner.com/blog/blog_13/","summary":"find() 方法 用法: array.find(callback[, thisArg])\n功能: 尋找符合指定條件的 第一個元素, 如果找到則返回該元素, 否則返回 undefined.\ncallback:\n接受 3 個參數:\nelement: 當前遍歷到的陣列元素.\nindex(可選): 當前遍歷到的陣列元素的索引.\narray(可選): 被遍歷的陣列.\n返回值: 如果符合指定條件, 則返回 true, 否則返回 false.\nfind() 範例 const arr = [1, 2, 3, 4, 5]; const result = arr.find((num) =\u0026gt; num \u0026gt; 3); console.log(result); // 4 (num) =\u0026gt; num \u0026gt; 3 是回調函數, 用來判斷陣列中的每個元素是否大於 3, 當 第一個 符合條件的元素被找到時, 該元素就會成為 find() 方法的返回值.\nnum 是當前遍歷到的陣列元素.\nnum \u0026gt; 3 表示判斷當前的元素是否大於 3.","title":"JavaScript find() \u0026 reduce() 用法和差異"},{"content":" html https://www.editorx.com/\n可以直接參考上面的設計樣式, 或直接在上自行設計之後再刻畫面.\n可以配合 RWD 設計不同版面.\ncss https://caniuse.com/\n查詢各種 css 屬性, 那些瀏覽器版本支援. https://coolors.co/e67e22\n可以在上面直接找顏色列表.\n可以比較顏色對比度.\nhttps://www.zhangxinxu.com/sp/filter.html\n顏色轉換成 css filter https://uiverse.io/\n可以找到各種 css 動畫效果. svg, png, webp https://heroicons.com/\n查找 svg 用. https://ionic.io/ionicons\n查找 svg 用. https://squoosh.app/\n可以壓縮圖片. 製圖 https://excalidraw.com/\n可以畫示意圖. https://tinysnap.app/\n用來美化截圖, 可以用在 chrome 插件. ","permalink":"https://www.jesseedgerunner.com/blog/blog_11/","summary":" html https://www.editorx.com/\n可以直接參考上面的設計樣式, 或直接在上自行設計之後再刻畫面.\n可以配合 RWD 設計不同版面.\ncss https://caniuse.com/\n查詢各種 css 屬性, 那些瀏覽器版本支援. https://coolors.co/e67e22\n可以在上面直接找顏色列表.\n可以比較顏色對比度.\nhttps://www.zhangxinxu.com/sp/filter.html\n顏色轉換成 css filter https://uiverse.io/\n可以找到各種 css 動畫效果. svg, png, webp https://heroicons.com/\n查找 svg 用. https://ionic.io/ionicons\n查找 svg 用. https://squoosh.app/\n可以壓縮圖片. 製圖 https://excalidraw.com/\n可以畫示意圖. https://tinysnap.app/\n用來美化截圖, 可以用在 chrome 插件. ","title":"常用網頁工具"},{"content":" 本週進度 投履歷囉!\nTODO.\n更新履歷.\n作品集整理.\n去比薪水留下 鼎盛 的評語.\n普天同慶 在跟 前 主管提完離職後, 無債一身, 把 104 履歷再次打開, 也開始遞履歷給自己心儀的公司, 在經過一系列奮鬥, 終於被錄取拉～～～\n新的公司主要在做資料相關的治理, 也有前後端分離, 但基本都要會, 也與我的職涯發展志同道合, 錄取後直接報到, 完全沒有猶豫, 面試那天看看環境的時候, 我看到每個人標配兩個螢幕, 寬敞的桌面, 乾淨的廁所, 衛生的茶水間, 著實讓我大開眼界, 感覺是把員工當人看的公司, 外面的世界還真大, 好險我跳出那潭泥沼了.\n新公司目前想給我的任務是做前端的部分, 也就是公司在使用的 Angular, 試用期也是以這做為評分標準, 接下來就是全力衝刺把前端的部分學好學滿.\n接下來該做什麼?\n加深 html \u0026amp; css 基礎.\n學習 Angular.\n","permalink":"https://www.jesseedgerunner.com/blog/blog_12/","summary":"本週進度 投履歷囉!\nTODO.\n更新履歷.\n作品集整理.\n去比薪水留下 鼎盛 的評語.\n普天同慶 在跟 前 主管提完離職後, 無債一身, 把 104 履歷再次打開, 也開始遞履歷給自己心儀的公司, 在經過一系列奮鬥, 終於被錄取拉～～～\n新的公司主要在做資料相關的治理, 也有前後端分離, 但基本都要會, 也與我的職涯發展志同道合, 錄取後直接報到, 完全沒有猶豫, 面試那天看看環境的時候, 我看到每個人標配兩個螢幕, 寬敞的桌面, 乾淨的廁所, 衛生的茶水間, 著實讓我大開眼界, 感覺是把員工當人看的公司, 外面的世界還真大, 好險我跳出那潭泥沼了.\n新公司目前想給我的任務是做前端的部分, 也就是公司在使用的 Angular, 試用期也是以這做為評分標準, 接下來就是全力衝刺把前端的部分學好學滿.\n接下來該做什麼?\n加深 html \u0026amp; css 基礎.\n學習 Angular.","title":"20230113 Weekly Report"},{"content":" 本週進度 本週主要在工作上的交接, 但說實在的交接的東習其實學長都看過了.\nTODO.\n公司.\n完成公司交代的功能.\n交接負責的部份.\n好好休息.\n不幹最大 終於有空更新了!\n前陣子被公司壓榨, 太忙根本沒有精力去做自己的事情, 終於受不了跟主管提離職後, 哇嗚, 整個態度都不一樣, 說話完全客客氣氣, 還想要加薪留人, 難道沒有意識到其實根本不是錢的問題嗎? 至少我現在相信員工會離職有一大部分都是因為 人, 反正這邊就是把違約金付一付, 高歌離席! 雖然繳完違約金後, 生活可能會過得有點苦, 也有點捨不得一起奮鬥的戰友, 但只有脫離這個險惡的環境, 我的身心才能得以休息.\n現在該做什麼?\n把公司原本指派的功能寫好.\n與學長交接之前負責的部分.\n存錢(違約金很貴).\n未來該做什麼?\n找工作.\n持續學習新技能(如前端框架等\u0026hellip;).\n","permalink":"https://www.jesseedgerunner.com/blog/blog_10/","summary":"本週進度 本週主要在工作上的交接, 但說實在的交接的東習其實學長都看過了.\nTODO.\n公司.\n完成公司交代的功能.\n交接負責的部份.\n好好休息.\n不幹最大 終於有空更新了!\n前陣子被公司壓榨, 太忙根本沒有精力去做自己的事情, 終於受不了跟主管提離職後, 哇嗚, 整個態度都不一樣, 說話完全客客氣氣, 還想要加薪留人, 難道沒有意識到其實根本不是錢的問題嗎? 至少我現在相信員工會離職有一大部分都是因為 人, 反正這邊就是把違約金付一付, 高歌離席! 雖然繳完違約金後, 生活可能會過得有點苦, 也有點捨不得一起奮鬥的戰友, 但只有脫離這個險惡的環境, 我的身心才能得以休息.\n現在該做什麼?\n把公司原本指派的功能寫好.\n與學長交接之前負責的部分.\n存錢(違約金很貴).\n未來該做什麼?\n找工作.\n持續學習新技能(如前端框架等\u0026hellip;).","title":"20221230 Weekly Report"},{"content":" 本週進度 這些日子許久沒更新了, 原本想說哪一間公司會這麼佛心, 培訓還給錢又幫忙分配工作, 但水很深啊\u0026hellip;\nTODO.\nMd.\n總結目前為止學到的特別技術. 公司.\n前台 Apis.\n後台 Apis.\n電文 Apis.\nCosera.\n獲得 Google Data Analytics 證書 11/30. 心力交瘁 這個月簡直疲勞轟炸, 好不容易通過考核期, 開心沒多久終於露出真面目了\u0026hellip;\n分發到的主管好像不怎麼會管理, 無償加班就算了(但也是很糟糕), 比較不解的是就只有新人沒有加班費, 除了我們之外其他人都有\u0026hellip; 也沒有前輩有空帶我們, 他們自身難保, 感覺在工作的分配上很有問題, 12 月初要交案的東西, 10 月中丟給我們做也沒有解釋, 就要我們自己生出來, 11 月開始要趕案子加班我能理解, 但不給加班費的理由竟然是\u0026quot;覺得這是你們該準時交的!\u0026quot;, 哇, 當初再從同事間選人的時候, 為什麼要選兩個要當兵教召三個禮拜的人呢? 等於原本 3 個人的工作量變成 2 人做, 再來怪新人沒有按時做出來, 優秀, 太優秀了, 平日加班到 9 點也不給吃飯, 禮拜六一早到晚上也不支薪.\n原本以為大公司不敢亂來, 看來是我太天真, 原來當初網友說的都是真的, 狗在這公司都比我們像人.\n為什麼不離職.\n培訓完後應工作一年, 不然要賠償金(不確定金額).\n工作未滿一年, 履歷不好看.\n青年就業補助應該到 01/06.\n為什麼該離職.\n不認可主管價值觀(想當年 blablabla).\n吃苦當吃補, 結果吃不飽.\n在學習上遇到天花板, 別組組員在學 jwt 我還在 crud.\n差別待遇.\n駐點單位環境非常差.\n同事即將離職, 公司不會補人力, 會要求繼續做功德.\n人生父母養, 出來就是糊口飯吃, 不用把人糟蹋成這樣, 歷練與壓榨其實還是有分別的, 又或者是我自己心態要有所成長, 目前還是要對自己該負起責任的東西負責到底, 自己選的工作就應該硬著頭洗完.\n前往 勞動基準法 =====\u0026gt; https://www.mol.gov.tw/1607/28162/28166/28168/28170/28989/\n前往 財團法人張老師基金會 =====\u0026gt; http://www.1980.org.tw\n","permalink":"https://www.jesseedgerunner.com/blog/blog_09/","summary":"本週進度 這些日子許久沒更新了, 原本想說哪一間公司會這麼佛心, 培訓還給錢又幫忙分配工作, 但水很深啊\u0026hellip;\nTODO.\nMd.\n總結目前為止學到的特別技術. 公司.\n前台 Apis.\n後台 Apis.\n電文 Apis.\nCosera.\n獲得 Google Data Analytics 證書 11/30. 心力交瘁 這個月簡直疲勞轟炸, 好不容易通過考核期, 開心沒多久終於露出真面目了\u0026hellip;\n分發到的主管好像不怎麼會管理, 無償加班就算了(但也是很糟糕), 比較不解的是就只有新人沒有加班費, 除了我們之外其他人都有\u0026hellip; 也沒有前輩有空帶我們, 他們自身難保, 感覺在工作的分配上很有問題, 12 月初要交案的東西, 10 月中丟給我們做也沒有解釋, 就要我們自己生出來, 11 月開始要趕案子加班我能理解, 但不給加班費的理由竟然是\u0026quot;覺得這是你們該準時交的!\u0026quot;, 哇, 當初再從同事間選人的時候, 為什麼要選兩個要當兵教召三個禮拜的人呢? 等於原本 3 個人的工作量變成 2 人做, 再來怪新人沒有按時做出來, 優秀, 太優秀了, 平日加班到 9 點也不給吃飯, 禮拜六一早到晚上也不支薪.\n原本以為大公司不敢亂來, 看來是我太天真, 原來當初網友說的都是真的, 狗在這公司都比我們像人.\n為什麼不離職.\n培訓完後應工作一年, 不然要賠償金(不確定金額).\n工作未滿一年, 履歷不好看.\n青年就業補助應該到 01/06.\n為什麼該離職.\n不認可主管價值觀(想當年 blablabla).","title":"20221123 Weekly Report"},{"content":" VsCode 主要常用在 Python, 前端開發, 有自動排版功能.\n自動排版.\n⌘(command) + ⇧(shift) + P 選擇通樣多項.\n⌘(command) + D 展開所有程式碼.\n⌘(command) + K + 0 收合所有程式碼.\n⌘(command) + K + J Intellij 主要用在 Java, 後端開發.\n選擇通樣多項.\ncontrol + G Windows Screen Shot.\nWin + Shift + S ","permalink":"https://www.jesseedgerunner.com/blog/blog_08/","summary":" VsCode 主要常用在 Python, 前端開發, 有自動排版功能.\n自動排版.\n⌘(command) + ⇧(shift) + P 選擇通樣多項.\n⌘(command) + D 展開所有程式碼.\n⌘(command) + K + 0 收合所有程式碼.\n⌘(command) + K + J Intellij 主要用在 Java, 後端開發.\n選擇通樣多項.\ncontrol + G Windows Screen Shot.\nWin + Shift + S ","title":"常用快捷"},{"content":" Optional 是什麼? Optional 是值的容器, 只有兩種狀態, 不是有值就是沒值.\n將輸入的值產生為 Optional 物件, 這時 Optional 物件即為該值的容器, 若要取回該值, 必須使用 get() 方法.\n將值轉為 Optional 的方法 of(): 接受 非 null 的值 並回傳 Optional 物件.\nofNullable(): 可以接受 null 的值, 回傳 Optional 物件.\n取得放在 Optional 物件內的值的方法 get(): 如果值存在就回傳這個值, 否則就丟出 NoSuchElementException.\norElse(T other): 如果值存在就回傳這個值, 否則回傳 other.\norElseGet(Supplier\u0026lt;? extends T\u0026gt; other): 如果值存在就回傳這個值, 否則就呼叫 other 並回傳它的結果.\norElseThrow(Supplier\u0026lt;? extends X\u0026gt; exceptionSupplier): 如果值存在就回傳這個值, 否則就丟出由 exceptionSupplier 建立的例外.\n常用範例 在 Repository 可以直接用 Optional, 這樣就可以避免資料庫互動時回 null 造成錯誤:\npublic interface DemoRepository extends JpaRepository\u0026lt;DemoEntity, String\u0026gt; { Optional\u0026lt;DemoEntity\u0026gt; findByGuid(String guid); } 在 Service 就可以依照以下方法使用它:\n@RequiredArgsConstructor @Service @Slf4j public class DemoService { @Autowired private DemoRepository demoRepository; public GuidRs getGuidDetail(GuidRq param) { GuidRs guidRs = new GuidRs(); // 利用 Optional 承接資料庫沒有這個值為 null var optEntity = demoRepository.findByGuid(param.getGuid()); // 再用 isPresent() 方法判斷是否為 null if (optEntity.isPresent()) { // get() 可以取得 Optional 裡的物件 DemoEntity temp = optEntity.get(); guidRs.setSomething(temp.getSomething()); } return guidRs; } } 參考資料 看原文文檔可以學更多喔!\nOptional 更多用法\nhttp://blog.tonycube.com/2015/10/java-java8-4-optional.html ","permalink":"https://www.jesseedgerunner.com/blog/blog_07/","summary":"Optional 是什麼? Optional 是值的容器, 只有兩種狀態, 不是有值就是沒值.\n將輸入的值產生為 Optional 物件, 這時 Optional 物件即為該值的容器, 若要取回該值, 必須使用 get() 方法.\n將值轉為 Optional 的方法 of(): 接受 非 null 的值 並回傳 Optional 物件.\nofNullable(): 可以接受 null 的值, 回傳 Optional 物件.\n取得放在 Optional 物件內的值的方法 get(): 如果值存在就回傳這個值, 否則就丟出 NoSuchElementException.\norElse(T other): 如果值存在就回傳這個值, 否則回傳 other.\norElseGet(Supplier\u0026lt;? extends T\u0026gt; other): 如果值存在就回傳這個值, 否則就呼叫 other 並回傳它的結果.\norElseThrow(Supplier\u0026lt;? extends X\u0026gt; exceptionSupplier): 如果值存在就回傳這個值, 否則就丟出由 exceptionSupplier 建立的例外.\n常用範例 在 Repository 可以直接用 Optional, 這樣就可以避免資料庫互動時回 null 造成錯誤:","title":"Java Optional 常用方法"},{"content":" jdbcTemplate Repository 負責與數據庫溝通, 運用 SQL 語言來操作 CRUD:\n@Repository public class DemoDao { @Autowired private JdbcTemplate jdbcTemplate; public void addStaff (ExampleEntity exampleEntity) { String sql = \u0026#34;INSERT INTO members(id, name) VALUES (?,?);\u0026#34;; jdbcTemplate.update(sql, exampleEntity.getId(), exampleEntity.getName()); } } execute.\n操作資料表相關的 SQL (create, drop…). update / batchUpdate.\n資料的新增、修改、刪除. query / queryForXXX.\n查詢資料. call.\nStored Procedure. JPA Repository extends JpaRepository:\npublic interface DemoRepository extends JpaRepository\u0026lt;DemoEntity, String\u0026gt; { DemoEntity findByGuid(String guid); List\u0026lt;DemoEntity\u0026gt; findByGuid(String guid); } 可以直接使用 JPA 的語法進行查詢, findByGuid = SELLECT \\* FROM Demo WHERE Guid = 'guid';, 也可以回傳該物件的 List, 但若需要更精細的查詢, 可以使用 JPQL.\n多個主鍵 在 JPA 如果要處理有多個 PK 的話, 可以寫一個包含所有主鍵的類:\n@Data // lombok 用法等於 @Getter @Setter, 但還有其他東西 public class PrimaryKey implements Serializable { private Integer id; private Integer userId; } 在 Entity 下加入:\n@Data @Entity @Table (name = \u0026#34;Demo\u0026#34;) @IdClass(Primarykey.class) @Equa lsAndHashCode (callSuper = true) @DynamicUpdate public class DemoEntity { @Id @Column(name = \u0026#34;id\u0026#34;, nullable = false) private Integer id; @Id @Column(name = \u0026#34;user_id\u0026#34;, nullable = false) private Integer userId; } 特殊 id uniqueidentifier(Transact-SQL):\n@Getter @Setter @AllArgsConstructor @NoArgsConstructor @Entity @Table(name = \u0026#34;FileCollection\u0026#34;, schema = \u0026#34;dbo\u0026#34;) public class FileCollectionEntity { @Id @GenericGenerator(name = \u0026#34;generator\u0026#34;, strategy = \u0026#34;uuid2\u0026#34;) @GeneratedValue(generator = \u0026#34;generator\u0026#34;) @Column(name = \u0026#34;FileGuid\u0026#34;, columnDefinition=\u0026#34;uniqueidentifier\u0026#34;) private String fileGuid; } 這樣就會自動產生特殊的 uuid 了.\nJPQL 一樣 extends JpaRepository:\npublic interface DemoRepository extends JpaRepository\u0026lt;DemoEntity, String\u0026gt; { @Query(\u0026#34;SELECT COUNT(e) FROM DemoEntity e\u0026#34;) long countAll(); } 意思是 SELECT COUNT(\\*) FROM Demo;, 然而 JPQL 並不支援 LIMIT 語法, 可以用 Pageable 進行限制, 在 Repository 傳入 Pageable 物件:\npublic interface DemoRepository extends JpaRepository\u0026lt;DemoEntity, String\u0026gt; { @Query(\u0026#34;SELECT d.urpn, COUNT(d.urpn) AS t FROM DemoEntity d GROUP BY d.urpn ORDER BY t DESC\u0026#34;) List\u0026lt;String\u0026gt; countUsRef(Pageable pageable); } 接著在呼叫的方法加入 PageRequest.of(page, size):\nDemoRepository.countUsRef(PageRequest.of(0,10)); 意思是第 0 頁, 每 10 筆 一頁.\n參考資料 看原文文檔可以學更多喔!\nJdbcTemplate\nhttps://medium.com/@steph.c/jdbctemplate-範例-2c9a1f3718ba Spring Boot JPA @Query\nhttps://www.baeldung.com/spring-data-jpa-query Spring Boot JPA 使用以及設置多個主键\nhttps://blog.csdn.net/xx326664162/article/details/80053719 ","permalink":"https://www.jesseedgerunner.com/blog/blog_06/","summary":"jdbcTemplate Repository 負責與數據庫溝通, 運用 SQL 語言來操作 CRUD:\n@Repository public class DemoDao { @Autowired private JdbcTemplate jdbcTemplate; public void addStaff (ExampleEntity exampleEntity) { String sql = \u0026#34;INSERT INTO members(id, name) VALUES (?,?);\u0026#34;; jdbcTemplate.update(sql, exampleEntity.getId(), exampleEntity.getName()); } } execute.\n操作資料表相關的 SQL (create, drop…). update / batchUpdate.\n資料的新增、修改、刪除. query / queryForXXX.\n查詢資料. call.\nStored Procedure. JPA Repository extends JpaRepository:\npublic interface DemoRepository extends JpaRepository\u0026lt;DemoEntity, String\u0026gt; { DemoEntity findByGuid(String guid); List\u0026lt;DemoEntity\u0026gt; findByGuid(String guid); } 可以直接使用 JPA 的語法進行查詢, findByGuid = SELLECT \\* FROM Demo WHERE Guid = 'guid';, 也可以回傳該物件的 List, 但若需要更精細的查詢, 可以使用 JPQL.","title":"Java query 常用方法"},{"content":" 本週進度 這幾天來做個小總結, 大概一個星期總結一次好了.\nTODO.\nMd.\n前端過程. Sts.\n改寫 票交端操作紀錄查詢 10/12. Angular.\n完成 300 頁 ppt 教學.\nYoutube 影片 2 hrs.\nCosera.\n- 把 Data 課程修完 10/17. 靈感爆炸 這禮拜經過 Cyberpunk: Edgerunners 的心靈轟炸後, 想要給 David \u0026amp; Lucy 一個好結局的我, 開始尋找有沒有畫家給他們一個好結局, 剛好在 Patreon 上有看到喜歡的畫作, 忍不住給他敗下去, 雖然平常喜歡當免費仔省錢, 但對於創作者的心血結晶, 用錢錢支持是必須的, 畢竟好的藝術家比日本壓縮機還要稀少.\n突然一個想法由然而生, 我想要一個私人畫廊擺放這些藝術品, 但總不可能真的租一個畫廊來放吧, 就這麼剛好, 我看到了角落的 Ocules, 看來阿毛又要開始點技能樹囉! Metaverse 裡面可以設計建築物並且開放參觀啊!!! 只是需要學會建模軟體 Blender, 遊戲引擎 Unity, 以及部署在 Metaverse 使用的 Mona, 於是決定開新坑, 若成功後可以再將其當作一個展示平台, 並串聯其他所學的技術.\n目前想到的點子.\n開放讓限定的使用者參觀.\n展示 NFT.\n串接其他平台.\n前往 Blender =====\u0026gt; https://www.blender.org\n前往 Unity =====\u0026gt; https://unity.com\n前往 Mona =====\u0026gt; https://docs.monaverse.com/get-started\n","permalink":"https://www.jesseedgerunner.com/blog/blog_05/","summary":"本週進度 這幾天來做個小總結, 大概一個星期總結一次好了.\nTODO.\nMd.\n前端過程. Sts.\n改寫 票交端操作紀錄查詢 10/12. Angular.\n完成 300 頁 ppt 教學.\nYoutube 影片 2 hrs.\nCosera.\n- 把 Data 課程修完 10/17. 靈感爆炸 這禮拜經過 Cyberpunk: Edgerunners 的心靈轟炸後, 想要給 David \u0026amp; Lucy 一個好結局的我, 開始尋找有沒有畫家給他們一個好結局, 剛好在 Patreon 上有看到喜歡的畫作, 忍不住給他敗下去, 雖然平常喜歡當免費仔省錢, 但對於創作者的心血結晶, 用錢錢支持是必須的, 畢竟好的藝術家比日本壓縮機還要稀少.\n突然一個想法由然而生, 我想要一個私人畫廊擺放這些藝術品, 但總不可能真的租一個畫廊來放吧, 就這麼剛好, 我看到了角落的 Ocules, 看來阿毛又要開始點技能樹囉! Metaverse 裡面可以設計建築物並且開放參觀啊!!! 只是需要學會建模軟體 Blender, 遊戲引擎 Unity, 以及部署在 Metaverse 使用的 Mona, 於是決定開新坑, 若成功後可以再將其當作一個展示平台, 並串聯其他所學的技術.\n目前想到的點子.\n開放讓限定的使用者參觀.\n展示 NFT.","title":"20220930 Weekly Report"},{"content":" 目前支援 highlight 的程式語言 powershell\nbash\nshell\nzsh 待修改\nscss\nplaintext\ntypescript\nswift\ngradle\nnginx\nxml\nphp\nruby\njavascript\nscala\nproperties\njson\ncmake\ndiff\ncss\naspectj\nmarkdown\npython\npython-repl\nobjectivec\ndust\nr\ndart\nsql\nlua\nc\nini\nmakefile\nclean\ngroovy\nless\nvbnet\ngraphql\nperl\ncsharp\nyaml\ndockerfile\nrust\ngo\nkotlin\ncpp\nbasic\nwasm\njava\nhttp\n","permalink":"https://www.jesseedgerunner.com/blog/blog_04/","summary":"目前支援 highlight 的程式語言 powershell\nbash\nshell\nzsh 待修改\nscss\nplaintext\ntypescript\nswift\ngradle\nnginx\nxml\nphp\nruby\njavascript\nscala\nproperties\njson\ncmake\ndiff\ncss\naspectj\nmarkdown\npython\npython-repl\nobjectivec\ndust\nr\ndart\nsql\nlua\nc\nini\nmakefile\nclean\ngroovy\nless\nvbnet\ngraphql\nperl\ncsharp\nyaml\ndockerfile\nrust\ngo\nkotlin\ncpp\nbasic\nwasm\njava\nhttp","title":"highlight.min.js 目前支援"},{"content":" # 標題大小與 \u0026lt;h1\u0026gt; ~ \u0026lt;h6\u0026gt; 對應 # = \u0026lt;h1\u0026gt;.\n## = \u0026lt;h2\u0026gt;.\n### = \u0026lt;h3\u0026gt;.\n#### = \u0026lt;h4\u0026gt;.\n##### = \u0026lt;h5\u0026gt;.\n###### = \u0026lt;h6\u0026gt;.\nHighlight 我是一般字型.\n我是強調字型.\nCode \u0026lt;body\u0026gt;\u0026lt;/body\u0026gt;.\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Blockquote 小白每天起床都會說: 今天天氣好好.\nTable AAA BBB CCC ABC EDF GHI 123 456 789 List fruit.\napple.\nbanana.\nmeat.\nbeef.\nchicken.\nWrite the press release.\nUpdate the website.\nContact the media.\nMath $$ c = \\sqrt{a^{2}+b_{xy}^{2}+e^{x}} $$\n參考資料 看原文文檔可以學更多喔!\n.md 進階用法\nhttps://www.markdownguide.org/extended-syntax/ .md Syntax highlighting 進階用法\nhttps://gohugo.io/content-management/syntax-highlighting/\nhttps://docs.github.com/en/get-started/writing-on-github/working-with-advanced-formatting/creating-and-highlighting-code-blocks\n","permalink":"https://www.jesseedgerunner.com/blog/blog_03/","summary":"# 標題大小與 \u0026lt;h1\u0026gt; ~ \u0026lt;h6\u0026gt; 對應 # = \u0026lt;h1\u0026gt;.\n## = \u0026lt;h2\u0026gt;.\n### = \u0026lt;h3\u0026gt;.\n#### = \u0026lt;h4\u0026gt;.\n##### = \u0026lt;h5\u0026gt;.\n###### = \u0026lt;h6\u0026gt;.\nHighlight 我是一般字型.\n我是強調字型.\nCode \u0026lt;body\u0026gt;\u0026lt;/body\u0026gt;.\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Blockquote 小白每天起床都會說: 今天天氣好好.\nTable AAA BBB CCC ABC EDF GHI 123 456 789 List fruit.\napple.\nbanana.\nmeat.\nbeef.\nchicken.\nWrite the press release.","title":".md 常用方法"},{"content":" 尊重友善包起來! 先申明, 很感謝公司成為我的衣食父母, 但是 私人 電腦不讓我刪除試用期裝的公司防毒就太過分囉.\nGoogle Chrome 是病毒! 對, 你沒看錯, 阿毛遇到的情況是裝了防毒軟體後連 Chrome 都開不起來, 身為一個軟體工程師, 隨身攜帶 Ctrl + C / Ctrl + V 也是非常合情合理的, 但你這樣搞不是要斷我生路嗎?\n嘗試刪除 Symantec Endpoint Protection 當你移除 Symantec Endpoint Protection, 他會自動跑出 Uninstall 畫面:\n在你滿心歡喜的按下 Uninstall 則會出現:\n需要公司提供的 密碼 才能解鎖卸載!\n繞過公司密碼刪除 Symantec Endpoint Protection 前往 Broadcom =====\u0026gt; https://knowledge.broadcom.com/external/article/151387\n下載 RemoveSymantecMacFiles.zip 並解壓縮, 執行 RemoveSymantecMacFiles.command, 此時會需要輸入電腦的使用者密碼:\n********* RemoveSymantecMacFiles.command 8.0.3 ********* You must be an admin user to run this script. Please enter your admin password: 輸入完會出現兩個選項:\n********* RemoveSymantecMacFiles.command 8.0.3 ********* WARNING: This script will remove all files and folders created by Symantec OS X products (except Symantec Adminstration Console for Macintosh files) and any files within those folders. Therefore, you will lose ALL files that reside in those folders, including any that you have created. 1 - Remove all Symantec files/folders. 2 - Quit. Do not remove any files. Enter choice (1 or 2): 輸入 1, 會移除 \u0026ldquo;所有\u0026rdquo; 有關 Symantec 的檔案 輸入 2, 不會做任何動作, 並退出 RemoveSymantecMacFiles.command 輸入 1 之後經過一段時間的執行, 電腦會重新開機.\n你擺脫惡意程式了! ","permalink":"https://www.jesseedgerunner.com/articles/articale_03/","summary":"尊重友善包起來! 先申明, 很感謝公司成為我的衣食父母, 但是 私人 電腦不讓我刪除試用期裝的公司防毒就太過分囉.\nGoogle Chrome 是病毒! 對, 你沒看錯, 阿毛遇到的情況是裝了防毒軟體後連 Chrome 都開不起來, 身為一個軟體工程師, 隨身攜帶 Ctrl + C / Ctrl + V 也是非常合情合理的, 但你這樣搞不是要斷我生路嗎?\n嘗試刪除 Symantec Endpoint Protection 當你移除 Symantec Endpoint Protection, 他會自動跑出 Uninstall 畫面:\n在你滿心歡喜的按下 Uninstall 則會出現:\n需要公司提供的 密碼 才能解鎖卸載!\n繞過公司密碼刪除 Symantec Endpoint Protection 前往 Broadcom =====\u0026gt; https://knowledge.broadcom.com/external/article/151387\n下載 RemoveSymantecMacFiles.zip 並解壓縮, 執行 RemoveSymantecMacFiles.command, 此時會需要輸入電腦的使用者密碼:\n********* RemoveSymantecMacFiles.command 8.0.3 ********* You must be an admin user to run this script.","title":"Mac 刪除 Symantec Endpoint Protection"},{"content":" 變成喜歡的樣子! 通常 HUGO Theme 的開發者們都會設計很多可以變更的部分, 以主題 onelou 為範例, 該作者設計了 logo 區塊 \u0026amp; SVG 區塊等, 所以可以換上自己網站的 logo 以及自己設計的 SVG 圖片.\nLogo Design 我們先從網頁的 logo 開始吧.\n製作網站 logo 前往 DesignEvo =====\u0026gt; https://www.designevo.com/tw/\n中文介面, 適合剛接觸設計的新手, 有許多板模可以直接套用並且可以自行修改, 可以 免費 匯出 300px X 300px 的圖檔.\n進入頁面後點選 免費製作 LOGO:\n選擇想要的主題:\n就可以開始修改成自己的 logo 了:\n可以善加利用 搜尋圖標 加入不同的圖, 但要記得用英文搜尋.\n設計完成後, 可以 免費 輸出 300px X 300px 的檔, 就算超過網站也會自動幫你轉成 300px X 300px.\n點選 免費下載一個低質量的 logo:\n但如果只想要保留圖形本體, 不要背景的話, DesignEvo 就要付費了, 身為一個優秀的免費仔, 要錢跟要命一樣, 所以這邊會用到這款去背軟體.\n前往 RemoveBg =====\u0026gt; https://www.remove.bg/zh/upload\n將剛剛設計好的圖片匯入 RemoveBg 就會自動去背拉:\n下載後, 將其改取代原本 static 資料夾裡的圖檔就可以了, 記得要將其像素壓縮 \u0026amp; css 排版調整一下, 網頁的專屬 logo 就完成了!\n製作 favicon.ico 前往 Aconvert =====\u0026gt; https://www.aconvert.com/tw/icon/png-to-ico\n.ico 就是 icon 檔案, 也就是瀏覽器最上方邊邊顯示的 icon, 可以作為縮圖標誌. 圖示檔的尺寸通常比較小, 常見的尺寸有 16px X 16px, 32px X 32px \u0026amp; 48px X 48px, 可以直接用來打開瀏覽.\nSVG Animation 接下來可以加上一些動畫.\n什麼是 SVG? 可縮放向量圖形 Scalable Vector Graphics: SVG 是一種向量圖形格式, 檔案尺寸比 PNG \u0026amp; JPG 還小, 常用於網站的 logo \u0026amp; icon 等\u0026hellip; 可以確保圖片在任何大小不失真.\n製作 SVG 前往 Figma =====\u0026gt; https://www.figma.com\n在製作 SVG 動畫之前, 需要先繪製一個向量圖形, 這裡使用 Figma 製作, 因為 Figma 在瀏覽器可以直接設計, 不需要再額外安裝有的沒有的軟體, 入門的門檻不高且 免費 方案就可以完成各式各樣的簡易向量圖形.\n註冊登入後, 進入主畫面:\n可以到 Community 搜尋想要使用的 Plugins, 這裡使用可以快速建立 SVG 的插件 Iconify:\n選擇自己喜歡的圖案就可以開始設計自己的 SVG 囉!\n匯出 SVG 的話只需要按下, 右下角的 Export Vector:\n記得匯出的檔案形式要選擇 .svg!\n製作 SVG 動畫 前往 SVGator =====\u0026gt; https://www.svgator.com\n註冊登入後, 就可以開始設計囉:\n調整每一個時間軸想要呈現的畫面後, 就可以按下右上角的 Export 匯出 SVG 動畫囉! 但這邊就要發揮我們的客家精神, 免費會員的動畫會受到限制, 例如隨著時間變化 SVG 顏色, 那就需要我們自己在 css 裡面加點東西.\n先找到該動畫所在的 css, 使用 @keyframes 決定什麼階段填滿什麼樣的顏色:\n@keyframes eewkZaUJCNo4_c_f { 0% { fill: #343232; } 7.692308% { fill: #cc7832; } 100% { fill: #cc7832; } } 原理跟 css 動畫是差不多的, 至於有什麼其他要調整的也都可以一起調整.\n參考 SVG 資源好去處\nhttps://iconmonstr.com SVG SMIL Animation 介紹\nhttps://blog.techbridge.cc/2021/06/21/svg-smil-animation-intro/ ","permalink":"https://www.jesseedgerunner.com/articles/articale_02/","summary":"變成喜歡的樣子! 通常 HUGO Theme 的開發者們都會設計很多可以變更的部分, 以主題 onelou 為範例, 該作者設計了 logo 區塊 \u0026amp; SVG 區塊等, 所以可以換上自己網站的 logo 以及自己設計的 SVG 圖片.\nLogo Design 我們先從網頁的 logo 開始吧.\n製作網站 logo 前往 DesignEvo =====\u0026gt; https://www.designevo.com/tw/\n中文介面, 適合剛接觸設計的新手, 有許多板模可以直接套用並且可以自行修改, 可以 免費 匯出 300px X 300px 的圖檔.\n進入頁面後點選 免費製作 LOGO:\n選擇想要的主題:\n就可以開始修改成自己的 logo 了:\n可以善加利用 搜尋圖標 加入不同的圖, 但要記得用英文搜尋.\n設計完成後, 可以 免費 輸出 300px X 300px 的檔, 就算超過網站也會自動幫你轉成 300px X 300px.\n點選 免費下載一個低質量的 logo:\n但如果只想要保留圖形本體, 不要背景的話, DesignEvo 就要付費了, 身為一個優秀的免費仔, 要錢跟要命一樣, 所以這邊會用到這款去背軟體.","title":"HUGO(2) HUGO Setting"},{"content":" 顯示 關閉顯示 隱藏檔案 ⌘(command) + ⇧(shift) + .\n刪除 .DS_Store ~ % sudo find / -name \u0026#34;.DS_Store\u0026#34; -depth -exec rm {} \\; 永久關閉 .DS_Store 檔案指令 ~ % defaults write com.apple.desktopservices DSDontWriteNetworkStores true 開啟 .DS_Store 檔案指令 ~ % defaults write com.apple.desktopservices DSDontWriteNetworkStores false ","permalink":"https://www.jesseedgerunner.com/blog/blog_02/","summary":" 顯示 關閉顯示 隱藏檔案 ⌘(command) + ⇧(shift) + .\n刪除 .DS_Store ~ % sudo find / -name \u0026#34;.DS_Store\u0026#34; -depth -exec rm {} \\; 永久關閉 .DS_Store 檔案指令 ~ % defaults write com.apple.desktopservices DSDontWriteNetworkStores true 開啟 .DS_Store 檔案指令 ~ % defaults write com.apple.desktopservices DSDontWriteNetworkStores false ","title":"刪除 .DS_Store"},{"content":" HUGO 前往 HUGO =====\u0026gt; https://gohugo.io\n簡單來說, HUGO 可以選擇不同的主題樣板讓你套用, 再自行修改裡面的內容, 能夠產生 靜態網站, 並且可以直接架在 GitHub.io 、 Netlify 等\u0026hellip;\n為了成為軟體工程師, 懶惰 \u0026amp; cost down 是不可或缺的特質, Hugo 宣稱他們是 The world\u0026rsquo;s fastest framework for building websites, 最重要的是 HUGO \u0026amp; GitHub Pages 都 不用錢!!!\n阿毛本身是用 mac 作為主要開發環境, 使用 windows 的建置方法可以參照 HUGO 的官網.\n安裝 Homebrew 先確認電腦有沒有安裝過 Homebrew:\n$ brew --version 如果沒有安裝過 Homebrew:\n$ /bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)\u0026#34; 安裝的時候會需要等一陣子, 裝完後再去查看, 最後應該會是這樣子:\n==\u0026gt; Installation successful! ==\u0026gt; Homebrew has enabled anonymous aggregate formulae and cask analytics. Read the analytics documentation (and how to opt-out) here: https://docs.brew.sh/Analytics No analytics data has been sent yet (nor will any be during this install run). ==\u0026gt; Homebrew is run entirely by unpaid volunteers. Please consider donating: https://github.com/Homebrew/brew#donations ==\u0026gt; Next steps: - Run brew help to get started - Further documentation: https://docs.brew.sh 安裝 Hugo 用 Homebrew 下載 HUGO:\n$ brew install hugo 結果應該會是:\n==\u0026gt; Summary 🍺 /usr/local/Cellar/hugo/0.102.3: 48 files, 57.5MB ==\u0026gt; Running `brew cleanup hugo`... Disable this behaviour by setting HOMEBREW_NO_INSTALL_CLEANUP. Hide these hints with HOMEBREW_NO_ENV_HINTS (see `man brew`). 阿毛以前就下載過 Homebrew, 結果遇到衝突:\nfatal: Could not resolve HEAD to a revision ==\u0026gt; Searching for similarly named formulae... Error: No similarly named formulae found. Error: No available formula or cask with the name \u0026#34;hugo\u0026#34;. ==\u0026gt; Searching for a previously deleted formula (in the last month)... Error: No previously deleted formula found. ==\u0026gt; Searching taps on GitHub... Error: No formulae found in taps. 最懶的解決辦法就是解除安裝 Homebrew, 然後再重新安裝一次(注意!!! 刪除 Homebrew 會讓以前下載的 packages 也被刪除)\n$ /bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/uninstall.sh)\u0026#34; 最後可以確認 HUGO 的版本:\n$ hugo version 會回應:\nhugo v0.102.3+extended darwin/amd64 BuildDate=unknown 建立新的網站 建立一個新的網站, 資料夾名稱可以自己調整, 這裡先跟著官方的教學一樣:\n$ hugo new site quickstart 接著就可以在目錄底下找的你的新網站資料夾.\n選擇喜歡的主題套用 前往 Hugo Theme =====\u0026gt; https://themes.gohugo.io\n用主題為 https://themes.gohugo.io/themes/hugo-theme-onelou/ 為例, 必須先到網站資料夾裡面:\n$ cd quickstart 再來初始化 git:\nquickstart % git init 藉由 git 下載主題至 themes 資料夾:\nquickstart % git submodule add https://github.com/jyygithub/hugo-theme-onelou.git themes/onelou 在 site configuration 加入 theme(在 config.toml 檔案裡, 新增一行 theme = \u0026ldquo;onelou\u0026rdquo;):\nquickstart % echo theme = \\\u0026#34;onelou\\\u0026#34; \u0026gt;\u0026gt; config.toml 調整檔案位置 由於 HUGO Theme 是開源的, 因此每個人的寫作方式都不一樣, 有可能你今天選中的主題, 會跟網站資料夾有重複的地方.\n例如 quickstart/content \u0026amp; quickstart/themes/onelou/content, 因此我會將其整理移至網站資料夾, 並刪除 quickstart/themes/onelou/content, 也就看個人習慣囉.\n建立文章 在 /content/posts 資料夾中建立 .md:\nquickstart % hugo new posts/my-first-post.md 打開 .md 的話應該會長這樣:\n--- title: \u0026#34;2022-09-13\u0026#34; date: 2022-09-13T10:21:27+08:00 draft: true --- 將 draft 改為 false 就可以將其顯示到網站上囉.\ndraft: true draft: false 不顯示在網站上 顯示在網站上 進行本地端測試 啟動 HUGO 伺服器:\nquickstart % hugo server -D 終端機會呈現:\nStart building sites … hugo v0.102.3+extended darwin/amd64 BuildDate=unknown | EN -------------------+----- Pages | 15 Paginator pages | 0 Non-page files | 0 Static files | 8 Processed images | 0 Aliases | 3 Sitemaps | 1 Cleaned | 0 Built in 60 ms Watching for changes in /quickstart/{archetypes,content,data,layouts,static,themes} Watching for config changes in /quickstart/config.toml, /quickstart/themes/onelou/config.yaml Environment: \u0026#34;development\u0026#34; Serving pages from memory Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender Web Server is available at http://localhost:1313/ (bind address 127.0.0.1) Press Ctrl+C to stop 再連線至 =====\u0026gt; http://localhost:1313/\n本地端的測試就成功了!!!\n參考 官方文件\nhttps://gohugo.io/ ItHome Hugo 貼身打造個人部落格\nhttps://ithelp.ithome.com.tw/users/20106430/ironman/3613 ","permalink":"https://www.jesseedgerunner.com/articles/articale_01/","summary":"HUGO 前往 HUGO =====\u0026gt; https://gohugo.io\n簡單來說, HUGO 可以選擇不同的主題樣板讓你套用, 再自行修改裡面的內容, 能夠產生 靜態網站, 並且可以直接架在 GitHub.io 、 Netlify 等\u0026hellip;\n為了成為軟體工程師, 懶惰 \u0026amp; cost down 是不可或缺的特質, Hugo 宣稱他們是 The world\u0026rsquo;s fastest framework for building websites, 最重要的是 HUGO \u0026amp; GitHub Pages 都 不用錢!!!\n阿毛本身是用 mac 作為主要開發環境, 使用 windows 的建置方法可以參照 HUGO 的官網.\n安裝 Homebrew 先確認電腦有沒有安裝過 Homebrew:\n$ brew --version 如果沒有安裝過 Homebrew:\n$ /bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)\u0026#34; 安裝的時候會需要等一陣子, 裝完後再去查看, 最後應該會是這樣子:\n==\u0026gt; Installation successful! ==\u0026gt; Homebrew has enabled anonymous aggregate formulae and cask analytics.","title":"HUGO(1) Building a Personal Blog"},{"content":" 慶祝阿毛的 Blog 誕生 轉職之路遙遙無期,\n從 {一日科科, 終生顆顆} 跳脫可怕的輪回,\n當然很辛苦,\n但畢竟要對以前自己做的決定負責,\n就努力把自己的不足補滿吧,\n希望我的肝可以再撐一下.\nBlog 規劃放一些要完成的目標.\nTODO.\nWorkFlow.\n蹦出來的想法.\n可能還有一些拉哩拉匝的心情.\nArticals 主要放一些技術心得文章.\n建立的過程.\n仔細的教學.\n相關知識.\n遇到的 Bug \u0026amp; Solution.\nProjects 一些專案的詳細介紹.\n簡短的介紹會在 Github. ","permalink":"https://www.jesseedgerunner.com/blog/blog_01/","summary":" 慶祝阿毛的 Blog 誕生 轉職之路遙遙無期,\n從 {一日科科, 終生顆顆} 跳脫可怕的輪回,\n當然很辛苦,\n但畢竟要對以前自己做的決定負責,\n就努力把自己的不足補滿吧,\n希望我的肝可以再撐一下.\nBlog 規劃放一些要完成的目標.\nTODO.\nWorkFlow.\n蹦出來的想法.\n可能還有一些拉哩拉匝的心情.\nArticals 主要放一些技術心得文章.\n建立的過程.\n仔細的教學.\n相關知識.\n遇到的 Bug \u0026amp; Solution.\nProjects 一些專案的詳細介紹.\n簡短的介紹會在 Github. ","title":"開張大吉"}]